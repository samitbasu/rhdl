use std::collections::BTreeMap;

use fnv::FnvHashMap;
use log::debug;

use crate::rhdl_bits::alias::b8;

use crate::rhdl_core::Digital;
use crate::rhdl_core::TypedBits;
use crate::rhdl_core::ast::ast_impl::WrapOp;
use crate::rhdl_core::ast::source::source_location::SourceLocation;
use crate::rhdl_core::common::symtab::SymbolTable;
use crate::rhdl_core::error::rhdl_error;
use crate::rhdl_core::rhif::object::SourceDetails;
use crate::rhdl_core::rhif::spec::{AluBinary, Slot};
use crate::rhdl_core::rtl::remap::remap_operands;
use crate::rhdl_core::rtl::spec::OperandKind;
use crate::rhdl_core::rtl::spec::{CastKind, Concat, Operand};
use crate::rhdl_core::rtl::symbols::SymbolMap;
use crate::rhdl_core::types::bit_string::BitString;
use crate::rhdl_core::types::path::{Path, PathElement, PathError, bit_range, sub_kind};
use crate::rhdl_core::{Kind, rtl};
use crate::rhdl_core::{RHDLError, rhif};

use crate::rhdl_core::rhif::spec as hf;
use crate::rhdl_core::rtl::spec as tl;

use crate::rhdl_core::compiler::mir::error::{ICE, RHDLCompileError};

type Result<T> = std::result::Result<T, RHDLError>;

struct RTLCompiler<'a> {
    symbols: SymbolMap,
    object: &'a rhif::object::Object,
    symtab: SymbolTable<TypedBits, Kind, SourceDetails, OperandKind>,
    operand_map: BTreeMap<Operand, Slot>,
    reverse_operand_map: BTreeMap<Slot, Operand>,
    ops: Vec<rtl::object::LocatedOpCode>,
}

#[derive(Debug, Clone)]
struct DynamicPathInstance {
    concrete_path: Path,
    dynamic_slot_values: FnvHashMap<Slot, usize>,
}

/// This function is similar to [path_star], but it is more
/// special purpose. In [path_star], we calculate the set of
/// all possible paths generated by a template path. So, for example,
/// if the path is a.foo[n].bar[m].baz, we will generate a list
/// of paths of the kind
///      a.foo[0].bar[0].baz
///      a.foo[0].bar[1].baz
///      a.foo[1].bar[0].baz
///          etc.
/// The [path_star] function does not keep track of the assignments used
/// in the process (i.e., what is the assignment for `n` and `m` in each
/// of the above paths).  We need this info for converting dynamic indexing
/// into a lookup table.  So we need the function to return something like
///      (a.foo[0].bar[0].baz, {n -> 0, m -> 0})
///      (a.foo[0].bar[1].baz, {n -> 0, m -> 1})
///      (a.foo[1].bar[0].baz, {n -> 1, m -> 0})
///      (a.foo[1].bar[1].baz, {n -> 1, m -> 1})
fn path_star_with_index_tracking(
    object: &rhif::Object,
    kind: Kind,
    path: &Path,
) -> Result<Vec<DynamicPathInstance>> {
    debug!("path star with index tracking called with kind {kind:?} and path {path:?}");
    if !path.any_dynamic() {
        return Ok(vec![DynamicPathInstance {
            concrete_path: path.clone(),
            dynamic_slot_values: FnvHashMap::default(),
        }]);
    }
    if let Some(element) = path.iter().next() {
        match element {
            PathElement::DynamicIndex(slot) => {
                let Kind::Array(array) = kind else {
                    return Err(rhdl_error(PathError::DynamicIndexOnNonArray {
                        element: element.clone(),
                        kind,
                    }));
                };
                let slot_bits = object.kind(*slot).bits();
                let upper_limit = array.size.min(1 << slot_bits);
                let mut paths = Vec::new();
                for i in 0..upper_limit {
                    let path = std::iter::once(PathElement::Index(i))
                        .chain(path.iter().copied().skip(1))
                        .collect::<Path>();
                    let mut child_paths = path_star_with_index_tracking(object, kind, &path)?;
                    child_paths.iter_mut().for_each(|child| {
                        child.dynamic_slot_values.insert(*slot, i);
                    });
                    paths.extend(child_paths);
                }
                return Ok(paths);
            }
            p => {
                // We have a non-dynamic path element, like a.foo
                // We want to apply it to get the subtype
                let prefix_path = Path::with_element(*p);
                // The resulting kind we compute with [sub_kind]
                let prefix_kind = sub_kind(kind, &prefix_path)?;
                // Get a residual path
                let suffix_path = path.strip_prefix(&prefix_path)?;
                // Recurse
                let mut suffix_star =
                    path_star_with_index_tracking(object, prefix_kind, &suffix_path)?;
                suffix_star.iter_mut().for_each(|item| {
                    item.concrete_path = prefix_path.clone().join(&item.concrete_path)
                });
                return Ok(suffix_star);
            }
        }
    }
    Ok(vec![DynamicPathInstance {
        concrete_path: path.clone(),
        dynamic_slot_values: FnvHashMap::default(),
    }])
}

struct DynamicIndexDetails {
    discriminant: Operand,
    table: Box<[(tl::CaseArgument, Path)]>,
}

impl<'a> RTLCompiler<'a> {
    fn new(object: &'a rhif::object::Object) -> Self {
        let mut symbols = SymbolMap::default();
        symbols.source_set = object.symbols.source_set.clone();
        Self {
            object,
            symbols,
            symtab: SymbolTable::default(),
            operand_map: Default::default(),
            reverse_operand_map: Default::default(),
            ops: Default::default(),
        }
    }
    fn lit(&mut self, bits: TypedBits, loc: impl Into<SourceDetails>) -> Operand {
        self.symtab.lit(bits, loc.into())
    }
    fn reg(&mut self, kind: Kind, loc: impl Into<SourceDetails>) -> Operand {
        self.symtab.reg(kind, loc.into())
    }
    fn operand_bit_width(&self, operand: Operand) -> usize {
        match operand {
            Operand::Literal(literal_id) => self.symtab[literal_id].kind.bits(),
            Operand::Register(register_id) => self.symtab[register_id].bits(),
        }
    }
    fn operand_is_signed(&self, operand: Operand) -> bool {
        match operand {
            Operand::Literal(literal_id) => self.symtab[literal_id].kind.is_signed(),
            Operand::Register(register_id) => self.symtab[register_id].is_signed(),
        }
    }
    fn raise_ice(&self, cause: ICE, loc: SourceLocation) -> RHDLError {
        rhdl_error(RHDLCompileError {
            cause,
            src: self.object.symbols.source(),
            err_span: self.object.symbols.span(loc).into(),
        })
    }
    fn lop(&mut self, opcode: tl::OpCode, loc: SourceLocation) {
        self.ops.push((opcode, loc).into())
    }
    fn build_dynamic_index(
        &mut self,
        arg_kind: Kind,
        path: &Path,
        loc: SourceLocation,
    ) -> Result<DynamicIndexDetails> {
        let dynamic_slots: Vec<Slot> = path.dynamic_slots().copied().collect();
        // Each of the selectors should be a register.  Any literals should have
        // been removed.
        if !dynamic_slots
            .iter()
            .all(|&slot| matches!(slot, Slot::Register(_)))
        {
            return Err(self.raise_ice(ICE::DynamicIndexHasLiteral { path: path.clone() }, loc));
        }
        let dynamic_slot_bit_widths = dynamic_slots
            .iter()
            .map(|slot| self.object.kind(*slot).bits())
            .collect::<Vec<usize>>();
        // Create a tuple Kind that is the contatenation of the dynamic slot kinds
        let selector_kind = Kind::make_tuple(
            dynamic_slots
                .iter()
                .map(|slot| self.object.kind(*slot))
                .collect(),
        );
        // Allocate a register of this size.  It will hold the concatenation of the dynamic slots
        let discriminant = self.reg(selector_kind, loc);
        let dynamic_slots_as_operands = dynamic_slots
            .iter()
            .map(|slot| self.operand(*slot))
            .collect::<Vec<_>>();
        self.lop(
            tl::OpCode::Concat(tl::Concat {
                lhs: discriminant,
                args: dynamic_slots_as_operands,
            }),
            loc,
        );
        let path_list = path_star_with_index_tracking(self.object, arg_kind, path)?;
        let mut test_values = vec![];
        for case in &path_list {
            // Map the dynamic slots to their equivalent raw usize values.
            let dyn_slots = dynamic_slots
                .iter()
                .map(|slot| case.dynamic_slot_values[slot])
                .collect::<Vec<_>>();
            let dyn_slot_bit_strings = dyn_slots
                .iter()
                .zip(&dynamic_slot_bit_widths)
                .map(|(&value, &width)| {
                    BitString::from(TypedBits::from(value as u64).unsigned_cast(width).expect(
                        "Unsigned cast must succeed - the width was chosen to ensure it would",
                    ))
                })
                .flat_map(|bs| bs.bits().to_vec())
                .collect::<Vec<_>>();
            // Add the type information
            let dyn_slot_tb = TypedBits {
                bits: dyn_slot_bit_strings,
                kind: selector_kind,
            };
            let Operand::Literal(test_value) = self.lit(dyn_slot_tb, loc) else {
                panic!("Allocate literal returned a register?")
            };
            test_values.push((
                tl::CaseArgument::Literal(test_value),
                case.concrete_path.clone(),
            ))
        }
        Ok(DynamicIndexDetails {
            discriminant,
            table: test_values.into(),
        })
    }
    fn operand(&mut self, slot: Slot) -> Operand {
        if let Some(operand) = self.reverse_operand_map.get(&slot) {
            return *operand;
        }
        let details = self.object.symtab[slot].clone();
        let operand = match slot {
            Slot::Literal(literal_id) => {
                let bits = &self.object.symtab[literal_id];
                self.lit(bits.clone(), details)
            }
            Slot::Register(register_id) => {
                let kind = self.object.symtab[register_id];
                self.reg(kind, details)
            }
        };
        self.operand_map.insert(operand, slot);
        self.reverse_operand_map.insert(slot, operand);
        operand
    }
    fn make_operand_list(&mut self, args: &[Slot]) -> Vec<Operand> {
        args.iter()
            .filter_map(|a| {
                if self.object.kind(*a).is_empty() {
                    None
                } else {
                    Some(self.operand(*a))
                }
            })
            .collect()
    }
    fn make_array(&mut self, args: &hf::Array, loc: SourceLocation) -> Result<()> {
        let hf::Array { lhs, elements } = args;
        if self.object.kind(*lhs).is_empty() {
            return Ok(());
        }
        let lhs = self.operand(*lhs);
        let elements = self.make_operand_list(elements);
        self.lop(
            tl::OpCode::Concat(tl::Concat {
                lhs,
                args: elements,
            }),
            loc,
        );
        Ok(())
    }
    fn make_resize(&mut self, cast: &hf::Cast, loc: SourceLocation) -> Result<()> {
        let hf::Cast { lhs, arg, len } = cast;
        let len = len.ok_or_else(|| self.raise_ice(ICE::BitCastMissingRequiredLength, loc))?;
        if !self.object.kind(*lhs).is_empty() && !self.object.kind(*arg).is_empty() {
            let lhs = self.operand(*lhs);
            let op_arg = self.operand(*arg);
            self.lop(
                tl::OpCode::Cast(tl::Cast {
                    lhs,
                    arg: op_arg,
                    len,
                    kind: CastKind::Resize,
                }),
                loc,
            );
        }
        Ok(())
    }
    fn make_wrap(&mut self, wrap: &hf::Wrap, loc: SourceLocation) -> Result<()> {
        let hf::Wrap { lhs, op, arg, kind } = wrap;
        let kind = kind.ok_or_else(|| self.raise_ice(ICE::WrapMissingKind, loc))?;
        let discriminant = match op {
            WrapOp::Ok | WrapOp::Some => self.lit(true.typed_bits(), loc),
            WrapOp::Err | WrapOp::None => self.lit(false.typed_bits(), loc),
        };
        let width = kind.bits() - 1;
        let lhs = self.operand(*lhs);
        if width != 0 {
            let payload = self.reg(Kind::Bits(width), loc);
            let arg = *arg;
            let arg = self.operand(arg);
            self.lop(
                tl::OpCode::Cast(tl::Cast {
                    lhs: payload,
                    arg,
                    len: width,
                    kind: CastKind::Resize,
                }),
                loc,
            );
            self.lop(
                tl::OpCode::Concat(Concat {
                    lhs,
                    args: vec![payload, discriminant],
                }),
                loc,
            );
        } else {
            self.lop(
                tl::OpCode::Assign(tl::Assign {
                    lhs,
                    rhs: discriminant,
                }),
                loc,
            );
        };
        Ok(())
    }
    fn make_as_bits(&mut self, cast: &hf::Cast, loc: SourceLocation) -> Result<()> {
        let hf::Cast { lhs, arg, len } = cast;
        let len = len.ok_or_else(|| self.raise_ice(ICE::BitCastMissingRequiredLength, loc))?;
        if !self.object.kind(*lhs).is_empty() && !self.object.kind(*arg).is_empty() {
            let lhs = self.operand(*lhs);
            let arg = self.operand(*arg);
            self.lop(
                tl::OpCode::Cast(tl::Cast {
                    lhs,
                    arg,
                    len,
                    kind: CastKind::Unsigned,
                }),
                loc,
            );
        }
        Ok(())
    }
    fn make_as_signed(&mut self, cast: &hf::Cast, loc: SourceLocation) -> Result<()> {
        let hf::Cast { lhs, arg, len } = cast;
        let len = len.ok_or_else(|| self.raise_ice(ICE::BitCastMissingRequiredLength, loc))?;
        if !self.object.kind(*lhs).is_empty() && !self.object.kind(*arg).is_empty() {
            let lhs = self.operand(*lhs);
            let arg = self.operand(*arg);
            self.lop(
                tl::OpCode::Cast(tl::Cast {
                    lhs,
                    arg,
                    len,
                    kind: CastKind::Signed,
                }),
                loc,
            );
        }
        Ok(())
    }
    fn make_assign(&mut self, assign: &hf::Assign, loc: SourceLocation) -> Result<()> {
        let hf::Assign { lhs, rhs } = assign;
        if !self.object.kind(*lhs).is_empty() && !self.object.kind(*rhs).is_empty() {
            let lhs = self.operand(*lhs);
            let rhs = self.operand(*rhs);
            self.lop(tl::OpCode::Assign(tl::Assign { lhs, rhs }), loc);
        }
        Ok(())
    }
    fn make_xadd_or_xmul(
        &mut self,
        lhs: Operand,
        arg1: Operand,
        arg2: Operand,
        loc: SourceLocation,
        op: tl::AluBinary,
    ) -> Result<()> {
        let Operand::Register(lhs_id) = lhs else {
            return Err(self.raise_ice(ICE::XopsResultMustBeRegister, loc));
        };
        let lhs_reg_kind = self.symtab[&lhs_id];
        let arg1_cast = self.reg(lhs_reg_kind, loc);
        let arg2_cast = self.reg(lhs_reg_kind, loc);
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg1_cast,
                arg: arg1,
                len: lhs_reg_kind.bits(),
                kind: CastKind::Resize,
            }),
            loc,
        );
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg2_cast,
                arg: arg2,
                len: lhs_reg_kind.bits(),
                kind: CastKind::Resize,
            }),
            loc,
        );
        self.lop(
            tl::OpCode::Binary(tl::Binary {
                lhs,
                op,
                arg1: arg1_cast,
                arg2: arg2_cast,
            }),
            loc,
        );
        Ok(())
    }
    fn make_xsub(
        &mut self,
        lhs: Operand,
        arg1: Operand,
        arg2: Operand,
        loc: SourceLocation,
    ) -> Result<()> {
        let Operand::Register(lhs_id) = lhs else {
            return Err(self.raise_ice(ICE::XopsResultMustBeRegister, loc));
        };
        // The cast operation has to be split into two steps depending
        // on the sign of the operands.  The result is always signed.
        let lhs_reg_kind = self.symtab[&lhs_id];
        let lhs_len = lhs_reg_kind.bits();
        let extension_kind = if self.operand_is_signed(arg1) {
            Kind::Signed(lhs_len)
        } else {
            Kind::Bits(lhs_len)
        };
        // First we extend the operands to the required number of bits
        let arg1_extend = self.reg(extension_kind, loc);
        let arg2_extend = self.reg(extension_kind, loc);
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg1_extend,
                arg: arg1,
                len: lhs_len,
                kind: CastKind::Resize,
            }),
            loc,
        );
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg2_extend,
                arg: arg2,
                len: lhs_len,
                kind: CastKind::Resize,
            }),
            loc,
        );
        // This guarantees that the sign bit will be zero when we reinterepret them as signed values
        let arg1_cast = self.reg(lhs_reg_kind, loc);
        let arg2_cast = self.reg(lhs_reg_kind, loc);
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg1_cast,
                arg: arg1_extend,
                len: lhs_reg_kind.bits(),
                kind: CastKind::Signed,
            }),
            loc,
        );
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg2_cast,
                arg: arg2_extend,
                len: lhs_reg_kind.bits(),
                kind: CastKind::Signed,
            }),
            loc,
        );
        self.lop(
            tl::OpCode::Binary(tl::Binary {
                lhs,
                op: tl::AluBinary::Sub,
                arg1: arg1_cast,
                arg2: arg2_cast,
            }),
            loc,
        );
        Ok(())
    }
    fn make_binary(&mut self, binary: &hf::Binary, loc: SourceLocation) -> Result<()> {
        let hf::Binary {
            lhs,
            op,
            arg1,
            arg2,
        } = *binary;
        if self.object.kind(lhs).is_empty() {
            return Ok(());
        }
        let lhs = self.operand(lhs);
        let arg1 = self.operand(arg1);
        let arg2 = self.operand(arg2);
        let mut rtl_binop = |op| {
            self.lop(
                tl::OpCode::Binary(tl::Binary {
                    lhs,
                    op,
                    arg1,
                    arg2,
                }),
                loc,
            );
            Ok(())
        };
        match op {
            AluBinary::Add => rtl_binop(tl::AluBinary::Add),
            AluBinary::Sub => rtl_binop(tl::AluBinary::Sub),
            AluBinary::Mul => rtl_binop(tl::AluBinary::Mul),
            AluBinary::BitAnd => rtl_binop(tl::AluBinary::BitAnd),
            AluBinary::BitOr => rtl_binop(tl::AluBinary::BitOr),
            AluBinary::BitXor => rtl_binop(tl::AluBinary::BitXor),
            AluBinary::Shl => rtl_binop(tl::AluBinary::Shl),
            AluBinary::Shr => rtl_binop(tl::AluBinary::Shr),
            AluBinary::Eq => rtl_binop(tl::AluBinary::Eq),
            AluBinary::Ne => rtl_binop(tl::AluBinary::Ne),
            AluBinary::Lt => rtl_binop(tl::AluBinary::Lt),
            AluBinary::Le => rtl_binop(tl::AluBinary::Le),
            AluBinary::Gt => rtl_binop(tl::AluBinary::Gt),
            AluBinary::Ge => rtl_binop(tl::AluBinary::Ge),
            AluBinary::XAdd => self.make_xadd_or_xmul(lhs, arg1, arg2, loc, tl::AluBinary::Add),
            AluBinary::XSub => self.make_xsub(lhs, arg1, arg2, loc),
            AluBinary::XMul => self.make_xadd_or_xmul(lhs, arg1, arg2, loc, tl::AluBinary::Mul),
        }
    }
    fn make_case_argument(
        &mut self,
        case_argument: &hf::CaseArgument,
        loc: SourceLocation,
    ) -> Result<tl::CaseArgument> {
        match case_argument {
            hf::CaseArgument::Slot(slot) => {
                if !slot.is_lit() {
                    return Err(self.raise_ice(ICE::MatchPatternValueMustBeLiteral, loc));
                };
                let operand = self.operand(*slot);
                let Operand::Literal(literal_id) = operand else {
                    return Err(self.raise_ice(ICE::MatchPatternValueMustBeLiteral, loc));
                };
                Ok(tl::CaseArgument::Literal(literal_id))
            }
            hf::CaseArgument::Wild => Ok(tl::CaseArgument::Wild),
        }
    }
    fn make_case(&mut self, case: &hf::Case, loc: SourceLocation) -> Result<()> {
        let hf::Case {
            lhs,
            discriminant,
            table,
        } = case;
        if self.object.kind(*lhs).is_empty() {
            return Ok(());
        }
        let lhs = self.operand(*lhs);
        let discriminant = self.operand(*discriminant);
        let table = table
            .iter()
            .map(|(cond, val)| {
                let cond = self.make_case_argument(cond, loc)?;
                let val = self.operand(*val);
                Ok((cond, val))
            })
            .collect::<Result<Vec<_>>>()?;
        self.lop(
            tl::OpCode::Case(tl::Case {
                lhs,
                discriminant,
                table,
            }),
            loc,
        );
        Ok(())
    }
    fn make_dynamic_splice(&mut self, splice: &hf::Splice, loc: SourceLocation) -> Result<()> {
        let hf::Splice {
            lhs,
            orig,
            path,
            subst,
        } = splice;
        if self.object.kind(*lhs).is_empty() {
            return Ok(());
        }
        let arg_kind = self.object.kind(*orig);
        let details = self.build_dynamic_index(arg_kind, path, loc)?;
        let lhs_kind = self.object.kind(*lhs);
        let lhs = self.operand(*lhs);
        let orig = self.operand(*orig);
        let subst = self.operand(*subst);
        let mut table = vec![];
        for (literal, path) in details.table {
            let case_value = self.reg(lhs_kind, loc);
            let (bit_range, _) = bit_range(arg_kind, &path)?;
            self.lop(
                tl::OpCode::Splice(tl::Splice {
                    lhs: case_value,
                    orig,
                    bit_range,
                    value: subst,
                    path: path.clone(),
                }),
                loc,
            );
            table.push((literal, case_value));
        }
        self.lop(
            tl::OpCode::Case(tl::Case {
                lhs,
                discriminant: details.discriminant,
                table,
            }),
            loc,
        );
        Ok(())
    }
    fn make_enum(&mut self, enumerate: &hf::Enum, id: SourceLocation) -> Result<()> {
        let hf::Enum {
            lhs,
            fields,
            template,
        } = enumerate;
        if self.object.kind(*lhs).is_empty() {
            return Ok(());
        }
        let kind = template.kind;
        let discriminant = template.discriminant()?.as_i64()?;
        let mut rhs = self.lit(template.clone(), id);
        for field in fields {
            let field_value = self.operand(field.value);
            let path = Path::default()
                .payload_by_value(discriminant)
                .member(&field.member);
            let (field_range, _) = bit_range(kind, &path)?;
            let reg = self.reg(kind, id);
            self.lop(
                tl::OpCode::Splice(tl::Splice {
                    lhs: reg,
                    orig: rhs,
                    bit_range: field_range,
                    value: field_value,
                    path: path.clone(),
                }),
                id,
            );
            rhs = reg;
        }
        let lhs = self.operand(*lhs);
        self.lop(tl::OpCode::Assign(tl::Assign { lhs, rhs }), id);
        Ok(())
    }
    fn make_exec(&mut self, exec: &hf::Exec, loc: SourceLocation) -> Result<()> {
        let hf::Exec { lhs, id, args } = exec;
        if self.object.kind(*lhs).is_empty() {
            return Ok(());
        }
        // Look up the function ID from the external functions.
        let func = &self.object.externals[id];
        // Compile it...
        let func = compile_rtl(func)?;
        // Merge in the symbols.  Each symbol in the executed function, now has a corresponding
        // symbol in our symbol table
        let mut op_remap = self.symtab.merge(func.symtab);
        // We just need to assign each argument from the called function to the corresponding
        // value from our symbol table.
        for (fn_arg, arg) in func.arguments.iter().zip(args) {
            if let Some(fn_reg) = fn_arg {
                let fn_reg_in_our_space = op_remap((*fn_reg).into());
                let argument_in_caller_space = self.operand(*arg);
                self.lop(
                    tl::OpCode::Assign(tl::Assign {
                        lhs: fn_reg_in_our_space,
                        rhs: argument_in_caller_space,
                    }),
                    loc,
                );
            }
        }
        let return_register = op_remap(func.return_register);
        // Translate each operation and add it to the existing function (inline).
        // Remap the operands of the opcode to allocate from the current function.
        // Note that we need to ensure that if a register is allocated it is reused..
        let translated = func
            .ops
            .into_iter()
            .map(|old_lop| {
                let op = remap_operands(old_lop.op, &mut op_remap);
                (op, old_lop.loc).into()
            })
            .collect::<Vec<_>>();
        self.ops.extend(translated);
        let lhs = self.operand(*lhs);
        self.lop(
            tl::OpCode::Assign(tl::Assign {
                lhs,
                rhs: return_register,
            }),
            loc,
        );
        self.symbols
            .source_set
            .extend(func.symbols.source_set.sources);
        Ok(())
    }
    /// Lower the RHIF dynamic index to RTL
    /// Note that the dynamic index op in RHIF is something like
    ///     a.foo[n].bar.baz[m]
    /// where (n, m) are the dynamic slots.  We will lower this into
    /// a case statement.  The final result will look something like
    ///      case (n,m) {
    ///          0, 0  => a.foo[0].bar.baz[0]
    ///          0, 1  => a.foo[0].bar.baz[1]
    ///           etc.
    ///      }
    fn make_dynamic_index(&mut self, index: &hf::Index, loc: SourceLocation) -> Result<()> {
        let hf::Index { lhs, arg, path } = index;
        if self.object.kind(*lhs).is_empty() {
            return Ok(());
        }
        let arg_kind = self.object.kind(*arg);
        let details = self.build_dynamic_index(arg_kind, path, loc)?;
        let lhs_kind = self.object.kind(index.lhs);
        let arg = self.operand(*arg);
        // Iterate over the cases
        let mut table = vec![];
        for (literal, path) in details.table {
            let case_value = self.reg(lhs_kind, loc);
            let (bit_range, _) = bit_range(arg_kind, &path)?;
            self.lop(
                tl::OpCode::Index(tl::Index {
                    lhs: case_value,
                    arg,
                    bit_range,
                    path: path.clone(),
                }),
                loc,
            );
            table.push((literal, case_value));
        }
        let lhs = self.operand(*lhs);
        self.lop(
            tl::OpCode::Case(tl::Case {
                lhs,
                discriminant: details.discriminant,
                table,
            }),
            loc,
        );
        Ok(())
    }
    fn make_index(&mut self, index: &hf::Index, loc: SourceLocation) -> Result<()> {
        if self.object.kind(index.lhs).is_empty() {
            return Ok(());
        }
        if index.path.any_dynamic() {
            return self.make_dynamic_index(index, loc);
        }
        let arg_ty = self.object.kind(index.arg);
        let (bit_range, _) = bit_range(arg_ty, &index.path)?;
        let lhs = self.operand(index.lhs);
        let arg = self.operand(index.arg);
        self.lop(
            tl::OpCode::Index(tl::Index {
                lhs,
                arg,
                bit_range,
                path: index.path.clone(),
            }),
            loc,
        );
        Ok(())
    }
    fn make_repeat(&mut self, repeat: &hf::Repeat, loc: SourceLocation) -> Result<()> {
        let hf::Repeat { lhs, value, len } = *repeat;
        if self.object.kind(lhs).is_empty() {
            return Ok(());
        }
        let lhs = self.operand(lhs);
        let arg = self.operand(value);
        let args = vec![arg; len as usize];
        self.lop(tl::OpCode::Concat(tl::Concat { lhs, args }), loc);
        Ok(())
    }
    fn make_retime(&mut self, retime: &hf::Retime, loc: SourceLocation) -> Result<()> {
        let hf::Retime { lhs, arg, color: _ } = *retime;
        if self.object.kind(lhs).is_empty() {
            return Ok(());
        }
        let lhs = self.operand(lhs);
        let rhs = self.operand(arg);
        self.lop(tl::OpCode::Assign(tl::Assign { lhs, rhs }), loc);
        Ok(())
    }
    fn make_select(&mut self, select: &hf::Select, loc: SourceLocation) -> Result<()> {
        let hf::Select {
            lhs,
            cond,
            true_value,
            false_value,
        } = *select;
        if self.object.kind(lhs).is_empty() {
            return Ok(());
        }
        let lhs = self.operand(lhs);
        let cond = self.operand(cond);
        let true_value = self.operand(true_value);
        let false_value = self.operand(false_value);
        self.lop(
            tl::OpCode::Select(tl::Select {
                lhs,
                cond,
                true_value,
                false_value,
            }),
            loc,
        );
        Ok(())
    }
    fn make_splice(&mut self, splice: &hf::Splice, loc: SourceLocation) -> Result<()> {
        if self.object.kind(splice.lhs).is_empty() {
            return Ok(());
        }
        if splice.path.any_dynamic() {
            return self.make_dynamic_splice(splice, loc);
        }
        let hf::Splice {
            lhs,
            orig,
            path,
            subst,
        } = splice;
        let orig_ty = self.object.kind(*orig);
        let (bit_range, _) = bit_range(orig_ty, path)?;
        let lhs = self.operand(*lhs);
        let orig = self.operand(*orig);
        let subst = self.operand(*subst);
        self.lop(
            tl::OpCode::Splice(tl::Splice {
                lhs,
                orig,
                bit_range,
                value: subst,
                path: path.clone(),
            }),
            loc,
        );
        Ok(())
    }
    fn make_struct(&mut self, strukt: &hf::Struct, loc: SourceLocation) -> Result<()> {
        let hf::Struct {
            lhs,
            fields,
            rest,
            template,
        } = strukt;
        if self.object.kind(*lhs).is_empty() {
            return Ok(());
        }
        let lhs = self.operand(*lhs);
        let kind = template.kind;
        let mut rhs = if let Some(rest) = rest {
            self.operand(*rest)
        } else {
            self.lit(template.clone(), loc)
        };
        for field in fields {
            let field_value = self.operand(field.value);
            let path = Path::default().member(&field.member);
            let (field_range, _) = bit_range(kind, &path)?;
            let reg = self.reg(kind, loc);
            self.lop(
                tl::OpCode::Splice(tl::Splice {
                    lhs: reg,
                    orig: rhs,
                    bit_range: field_range,
                    value: field_value,
                    path: path.clone(),
                }),
                loc,
            );
            rhs = reg;
        }
        self.lop(tl::OpCode::Assign(tl::Assign { lhs, rhs }), loc);
        Ok(())
    }
    fn make_tuple(&mut self, tuple: &hf::Tuple, loc: SourceLocation) -> Result<()> {
        let hf::Tuple { lhs, fields } = tuple;
        if self.object.kind(*lhs).is_empty() {
            return Ok(());
        }
        let lhs = self.operand(*lhs);
        let args = self.make_operand_list(fields);
        self.lop(tl::OpCode::Concat(tl::Concat { lhs, args }), loc);
        Ok(())
    }
    fn make_xshr(&mut self, lhs: Operand, arg: Operand, shift: usize, loc: SourceLocation) {
        // First apply the right shift operation
        let count = b8(shift as u128);
        let right_shift_amount = self.lit(count.typed_bits(), loc);
        let operand_bits = self.operand_bit_width(arg);
        let operand_signed = self.operand_is_signed(arg);
        let arg_shifted = if operand_signed {
            self.reg(Kind::Signed(operand_bits), loc)
        } else {
            self.reg(Kind::Bits(operand_bits), loc)
        };
        self.lop(
            tl::OpCode::Binary(tl::Binary {
                lhs: arg_shifted,
                op: tl::AluBinary::Shr,
                arg1: arg,
                arg2: right_shift_amount,
            }),
            loc,
        );
        // Now resize the result into the LHS
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs,
                arg: arg_shifted,
                len: operand_bits.saturating_sub(shift),
                kind: CastKind::Resize,
            }),
            loc,
        )
    }
    fn make_xshl(&mut self, lhs: Operand, arg: Operand, count: usize, loc: SourceLocation) {
        // First pad the operand by the shift count
        let arg_len = self.operand_bit_width(arg);
        let arg_padded = if self.operand_is_signed(arg) {
            self.reg(Kind::Signed(arg_len + count), loc)
        } else {
            self.reg(Kind::Bits(arg_len + count), loc)
        };
        // Now we resize cast the argument into this larger register
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg_padded,
                arg,
                len: arg_len + count,
                kind: CastKind::Resize,
            }),
            loc,
        );
        let count = b8(count as u128);
        let left_shift_amount = self.lit(count.typed_bits(), loc);
        // Now we issue the shl operation (lossy)
        self.lop(
            tl::OpCode::Binary(tl::Binary {
                lhs,
                op: tl::AluBinary::Shl,
                arg1: arg_padded,
                arg2: left_shift_amount,
            }),
            loc,
        );
    }
    fn make_xsgn(&mut self, lhs: Operand, arg: Operand, loc: SourceLocation) {
        // The argument must be unsigned.
        // First pad the width by 1 bit
        let arg_len = self.operand_bit_width(arg);
        let arg_padded = self.reg(Kind::Bits(arg_len + 1), loc);
        // Now we resize cast the argument into this larger register
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg_padded,
                arg,
                len: arg_len + 1,
                kind: CastKind::Resize,
            }),
            loc,
        );
        // Next, we cast it as signed in this larger size
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs,
                arg: arg_padded,
                len: arg_len + 1,
                kind: CastKind::Signed,
            }),
            loc,
        );
    }
    fn make_xneg(&mut self, lhs: Operand, arg: Operand, loc: SourceLocation) {
        // First pad the width by 1 bit
        let arg_len = self.operand_bit_width(arg);
        let mut arg_padded = if self.operand_is_signed(arg) {
            self.reg(Kind::Signed(arg_len + 1), loc)
        } else {
            self.reg(Kind::Bits(arg_len + 1), loc)
        };
        // Now we resize cast the argument into this larger register
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg_padded,
                arg,
                len: arg_len + 1,
                kind: CastKind::Resize,
            }),
            loc,
        );
        // We need an extra step if the argument is unsigned
        if !self.operand_is_signed(arg) {
            let padded_and_signed = self.reg(Kind::Signed(arg_len + 1), loc);
            self.lop(
                tl::OpCode::Cast(tl::Cast {
                    lhs: padded_and_signed,
                    arg: arg_padded,
                    len: arg_len + 1,
                    kind: CastKind::Signed,
                }),
                loc,
            );
            arg_padded = padded_and_signed;
        }
        // Now we can negate the value
        self.lop(
            tl::OpCode::Unary(tl::Unary {
                lhs,
                op: tl::AluUnary::Neg,
                arg1: arg_padded,
            }),
            loc,
        );
    }
    fn make_unary(&mut self, unary: &hf::Unary, loc: SourceLocation) -> Result<()> {
        let hf::Unary { lhs, op, arg1 } = *unary;
        if self.object.kind(lhs).is_empty() {
            return Ok(());
        }
        let lhs = self.operand(lhs);
        let arg1 = self.operand(arg1);
        let mut unop = |op| self.lop(tl::OpCode::Unary(tl::Unary { lhs, op, arg1 }), loc);
        match op {
            hf::AluUnary::Neg => unop(tl::AluUnary::Neg),
            hf::AluUnary::Not => unop(tl::AluUnary::Not),
            hf::AluUnary::All => unop(tl::AluUnary::All),
            hf::AluUnary::Any => unop(tl::AluUnary::Any),
            hf::AluUnary::Xor => unop(tl::AluUnary::Xor),
            hf::AluUnary::Signed => unop(tl::AluUnary::Signed),
            hf::AluUnary::Unsigned => unop(tl::AluUnary::Unsigned),
            hf::AluUnary::Val => unop(tl::AluUnary::Val),
            hf::AluUnary::XExt(_) => {
                let lhs_len = self.operand_bit_width(lhs);
                self.lop(
                    tl::OpCode::Cast(tl::Cast {
                        lhs,
                        arg: arg1,
                        len: lhs_len,
                        kind: CastKind::Resize,
                    }),
                    loc,
                );
            }
            hf::AluUnary::XShl(cnt) => self.make_xshl(lhs, arg1, cnt, loc),
            hf::AluUnary::XShr(cnt) => self.make_xshr(lhs, arg1, cnt, loc),
            hf::AluUnary::XNeg => self.make_xneg(lhs, arg1, loc),
            hf::AluUnary::XSgn => self.make_xsgn(lhs, arg1, loc),
        };
        Ok(())
    }
    fn translate(mut self) -> Result<Self> {
        for lop in self.object.ops.iter() {
            let loc = lop.loc;
            match &lop.op {
                hf::OpCode::Array(array) => {
                    self.make_array(array, loc)?;
                }
                hf::OpCode::AsBits(cast) => {
                    self.make_as_bits(cast, loc)?;
                }
                hf::OpCode::AsSigned(cast) => {
                    self.make_as_signed(cast, loc)?;
                }
                hf::OpCode::Assign(assign) => {
                    self.make_assign(assign, loc)?;
                }
                hf::OpCode::Binary(binary) => {
                    self.make_binary(binary, loc)?;
                }
                hf::OpCode::Case(case) => {
                    self.make_case(case, loc)?;
                }
                hf::OpCode::Comment(comment) => {
                    self.lop(tl::OpCode::Comment(comment.clone()), loc);
                }
                hf::OpCode::Enum(enumerate) => {
                    self.make_enum(enumerate, loc)?;
                }
                hf::OpCode::Exec(exec) => {
                    self.make_exec(exec, loc)?;
                }
                hf::OpCode::Index(index) => {
                    self.make_index(index, loc)?;
                }
                hf::OpCode::Noop => {}
                hf::OpCode::Resize(cast) => {
                    self.make_resize(cast, loc)?;
                }
                hf::OpCode::Repeat(repeat) => {
                    self.make_repeat(repeat, loc)?;
                }
                hf::OpCode::Retime(retime) => {
                    self.make_retime(retime, loc)?;
                }
                hf::OpCode::Select(select) => {
                    self.make_select(select, loc)?;
                }
                hf::OpCode::Splice(splice) => {
                    self.make_splice(splice, loc)?;
                }
                hf::OpCode::Struct(strukt) => {
                    self.make_struct(strukt, loc)?;
                }
                hf::OpCode::Tuple(tuple) => {
                    self.make_tuple(tuple, loc)?;
                }
                hf::OpCode::Unary(unary) => {
                    self.make_unary(unary, loc)?;
                }
                hf::OpCode::Wrap(wrap) => {
                    self.make_wrap(wrap, loc)?;
                }
            }
        }
        Ok(self)
    }
}

fn compile_rtl(object: &rhif::Object) -> Result<rtl::object::Object> {
    let mut compiler = RTLCompiler::new(object).translate()?;
    let arguments = object
        .arguments
        .iter()
        .map(|x| {
            if object.symtab[*x].is_empty() {
                None
            } else if let Operand::Register(reg_id) = compiler.operand(Slot::Register(*x)) {
                Some(reg_id)
            } else {
                None
            }
        })
        .collect();
    let return_register = compiler.reverse_operand_map[&object.return_slot];
    Ok(rtl::object::Object {
        symbols: compiler.symbols,
        symtab: compiler.symtab,
        return_register,
        ops: compiler.ops,
        arguments,
        name: object.name.clone(),
        fn_id: object.fn_id,
    })
}

pub fn compile_to_rtl(object: &rhif::object::Object) -> Result<rtl::object::Object> {
    compile_rtl(object)
}
