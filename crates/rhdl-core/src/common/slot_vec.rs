//! Indexed Vector support type
//!
//! This is akin to a SlotMap, but it has the following properties:
//!
//!  - The key is generated by pushing a value into the slot map
//!  - The key type is connected to the [SlotVec], so that you can
//!    create different key types for different [SlotVec] types.
//!  - Two slot maps can be merged, and a function is returned that
//!    maps the keys from the merged [SlotVec].
//!  - You can select out items from the [SlotVec] with a functional
//!    and unused items will be removed, and the keys reassigned.
//!
use std::collections::BTreeMap;
use std::hash::Hash;
use std::ops::{Index, IndexMut};

pub trait SlotKey: Copy + Clone + PartialEq + Eq + Ord + PartialOrd + Hash {
    fn new(id: u64, index: usize) -> Self;
    fn id(self) -> u64;
    fn index(self) -> usize;
}

#[derive(Clone, Hash)]
pub struct SlotVec<T, I> {
    id: u64,
    vals: Vec<T>,
    index: std::marker::PhantomData<I>,
}

impl<T, I> Default for SlotVec<T, I> {
    fn default() -> Self {
        Self {
            id: rand::random(),
            vals: Default::default(),
            index: Default::default(),
        }
    }
}

impl<T, I: SlotKey> SlotVec<T, I> {
    pub fn inner(&self) -> &[T] {
        &self.vals
    }
    #[must_use]
    pub fn push(&mut self, val: T) -> I {
        let ndx = self.vals.len();
        self.vals.push(val);
        I::new(self.id, ndx)
    }
    pub fn iter(&self) -> impl Iterator<Item = (I, &T)> + '_ {
        self.vals
            .iter()
            .enumerate()
            .map(|(ndx, val)| (I::new(self.id, ndx), val))
    }
    pub fn iter_mut(&mut self) -> impl Iterator<Item = (I, &mut T)> + '_ {
        self.vals
            .iter_mut()
            .enumerate()
            .map(|(ndx, val)| (I::new(self.id, ndx), val))
    }
    pub fn transmute<S, F>(self, mut f: F) -> SlotVec<S, I>
    where
        F: FnMut(I, T) -> S,
    {
        let vals = self
            .vals
            .into_iter()
            .enumerate()
            .map(|(index, val)| f(I::new(self.id, index), val))
            .collect();
        SlotVec {
            id: self.id,
            vals,
            index: std::marker::PhantomData,
        }
    }
    pub fn try_transmute<S, F>(self, mut f: F) -> Result<SlotVec<S, I>, RHDLError>
    where
        F: FnMut(I, T) -> Result<S, RHDLError>,
    {
        let vals = self
            .vals
            .into_iter()
            .enumerate()
            .map(|(index, val)| f(I::new(self.id, index), val))
            .collect::<Result<Vec<_>, RHDLError>>()?;
        Ok(SlotVec {
            id: self.id,
            vals,
            index: std::marker::PhantomData,
        })
    }
    #[must_use]
    pub fn merge(&mut self, mut other: Self) -> impl Fn(I) -> I + use<T, I> {
        let offset = self.vals.len();
        self.vals.append(&mut other.vals);
        let other_id = other.id;
        let self_id = self.id;
        move |index| {
            assert_eq!(
                index.id(),
                other_id,
                "Merge remap was applied to some other key.  Target id {}, other id {}, key id {}",
                self_id,
                other_id,
                index.id()
            );
            let ndx: usize = index.index() + offset;
            I::new(self_id, ndx)
        }
    }
    #[must_use]
    pub fn retain<F: Fn(I, &T) -> bool>(&mut self, f: F) -> impl Fn(I) -> Option<I> + use<T, I, F> {
        let mut reorder = BTreeMap::default();
        let mut counter = 0;
        let vals = std::mem::take(&mut self.vals);
        self.vals = vals
            .into_iter()
            .enumerate()
            .filter_map(|(ndx, val)| {
                if f(I::new(self.id, ndx), &val) {
                    reorder.insert(I::new(self.id, ndx), I::new(self.id, counter));
                    counter += 1;
                    Some(val)
                } else {
                    None
                }
            })
            .collect();
        move |index| reorder.get(&index).cloned()
    }
    pub fn is_key_valid(&self, index: I) -> bool {
        self.id == index.id() && index.index() < self.vals.len()
    }
}

impl<T, I: SlotKey> Index<I> for SlotVec<T, I> {
    type Output = T;

    fn index(&self, index: I) -> &Self::Output {
        assert_eq!(
            self.id,
            index.id(),
            "SlotVec with id {} was indexed with key of id {}",
            self.id,
            index.id()
        );
        let ndx: usize = index.index();
        &self.vals[ndx]
    }
}

impl<T, I: SlotKey> IndexMut<I> for SlotVec<T, I> {
    fn index_mut(&mut self, index: I) -> &mut Self::Output {
        assert_eq!(
            self.id,
            index.id(),
            "SlotVec with id {} was indexed with key of id {}",
            self.id,
            index.id()
        );
        let ndx: usize = index.index();
        &mut self.vals[ndx]
    }
}

impl<T, I: SlotKey> Index<&I> for SlotVec<T, I> {
    type Output = T;

    fn index(&self, index: &I) -> &Self::Output {
        assert_eq!(
            self.id,
            index.id(),
            "SlotVec with id {} was indexed with key of id {}",
            self.id,
            index.id()
        );
        let ndx: usize = index.index();
        &self.vals[ndx]
    }
}

impl<T, I: SlotKey> IndexMut<&I> for SlotVec<T, I> {
    fn index_mut(&mut self, index: &I) -> &mut Self::Output {
        assert_eq!(
            self.id,
            index.id(),
            "SlotVec with id {} was indexed with key of id {}",
            self.id,
            index.id()
        );
        let ndx: usize = index.index();
        &mut self.vals[ndx]
    }
}

#[macro_export]
macro_rules! new_key_type {
    ($name:ident,$abbrev:literal) => {
        #[derive(Copy, Clone, PartialEq, Eq, Ord, PartialOrd, Hash)]
        pub struct $name {
            id: u64,
            index: usize,
        }

        impl SlotKey for $name {
            fn new(id: u64, index: usize) -> $name {
                $name { id, index }
            }
            fn id(self) -> u64 {
                self.id
            }
            fn index(self) -> usize {
                self.index
            }
        }

        impl std::fmt::Display for $name {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "{}{}", $abbrev, self.index)
            }
        }

        impl std::fmt::Debug for $name {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "{}{}", $abbrev, self.index)
            }
        }
    };
}

pub use new_key_type;

use crate::prelude::RHDLError;

#[cfg(test)]
mod tests {
    use super::*;

    new_key_type!(Left, "l");

    new_key_type!(Right, "r");

    #[test]
    fn test_simple_indexing() {
        let mut left_vec = SlotVec::<u32, Left>::default();
        let literals = [1, 7, 42, 16, 32, 42, 15, 99]
            .iter()
            .map(|x| left_vec.push(*x))
            .collect::<Vec<Left>>();
        let lit = literals[2];
        assert_eq!(left_vec[lit], 42);
    }

    #[test]
    fn test_simple_merge() {
        let mut left_vec = SlotVec::<u32, Left>::default();
        let literals = [1, 7, 42, 16, 32, 42, 15, 99]
            .iter()
            .map(|x| left_vec.push(*x))
            .collect::<Vec<Left>>();
        let mut left_second = SlotVec::<u32, Left>::default();
        let second_literals = [1, 3, 5, 9]
            .iter()
            .map(|x| left_second.push(*x))
            .collect::<Vec<Left>>();
        // Merge the two lists of literals
        let remap = left_vec.merge(left_second);
        let all_literals = literals
            .into_iter()
            .chain(second_literals.into_iter().map(remap))
            .collect::<Vec<Left>>();
        assert_eq!(
            all_literals
                .into_iter()
                .map(SlotKey::index)
                .collect::<Vec<_>>(),
            (0..12).collect::<Vec<_>>()
        );
    }

    #[test]
    fn test_select() {
        let mut left_vec = SlotVec::<u32, Left>::default();
        let literals = [1, 7, 42, 16, 32, 42, 15, 99]
            .iter()
            .map(|x| left_vec.push(*x))
            .collect::<Vec<Left>>();
        let remap = left_vec.retain(|_ndx, val| *val != 42);
        let literals = literals
            .into_iter()
            .filter_map(remap)
            .collect::<Vec<Left>>();
        assert_eq!(literals.len(), 6);
        for val in left_vec.inner() {
            assert_ne!(*val, 42);
        }
        assert_eq!(
            literals.into_iter().map(SlotKey::index).collect::<Vec<_>>(),
            (0..6).collect::<Vec<_>>()
        );
    }

    #[test]
    fn test_cross_checks() {
        let mut left_vec_1 = SlotVec::<u32, Left>::default();
        let literals_1 = [1, 7, 42, 16, 32, 42, 15, 99]
            .iter()
            .map(|x| left_vec_1.push(*x))
            .collect::<Vec<Left>>();
        let mut left_vec_2 = SlotVec::<u32, Left>::default();
        let literals_2 = [1, 7, 42, 16, 32, 42, 15, 99]
            .iter()
            .map(|x| left_vec_2.push(*x))
            .collect::<Vec<Left>>();
        assert!(left_vec_1.is_key_valid(literals_1[0]));
        assert!(!left_vec_1.is_key_valid(literals_2[0]));
        assert!(left_vec_2.is_key_valid(literals_2[0]));
        assert!(!left_vec_2.is_key_valid(literals_1[0]));
    }

    #[test]
    #[should_panic]
    fn test_cross_panics() {
        let mut left_vec_1 = SlotVec::<u32, Left>::default();
        let _ = [1, 7, 42, 16, 32, 42, 15, 99]
            .iter()
            .map(|x| left_vec_1.push(*x))
            .collect::<Vec<Left>>();
        let mut left_vec_2 = SlotVec::<u32, Left>::default();
        let literals_2 = [1, 7, 42, 16, 32, 42, 15, 99]
            .iter()
            .map(|x| left_vec_2.push(*x))
            .collect::<Vec<Left>>();
        let _ = left_vec_1[literals_2[0]]; // Should panic!
    }
}
