impl rhdl :: core :: Digital for State { const BITS : usize = 3usize + rhdl :: const_max ! (0_usize , 0_usize , 0_usize , 0_usize , 0_usize , 0_usize) ; fn static_kind () -> rhdl :: core :: Kind { rhdl :: core :: Kind :: make_enum (concat ! (module_path ! () , "::" , stringify ! (State)) , [rhdl :: core :: Kind :: make_variant (stringify ! (Init) , rhdl :: core :: Kind :: Empty , 0i64) , rhdl :: core :: Kind :: make_variant (stringify ! (Boot) , rhdl :: core :: Kind :: Empty , 1i64) , rhdl :: core :: Kind :: make_variant (stringify ! (Running) , rhdl :: core :: Kind :: Empty , 2i64) , rhdl :: core :: Kind :: make_variant (stringify ! (Stop) , rhdl :: core :: Kind :: Empty , 3i64) , rhdl :: core :: Kind :: make_variant (stringify ! (Boom) , rhdl :: core :: Kind :: Empty , 4i64) , rhdl :: core :: Kind :: make_variant (stringify ! (Unknown) , rhdl :: core :: Kind :: Empty , 5i64)] . into () , rhdl :: core :: Kind :: make_discriminant_layout (3usize , rhdl :: core :: DiscriminantAlignment :: Msb , rhdl :: core :: DiscriminantType :: Unsigned)) } fn bin (self) -> Box < [rhdl :: core :: BitX] > { let mut raw = match self { Self :: Init => { rhdl :: core :: bitx_vec (& rhdl :: bits :: bits :: < 3 > (0i64 as u128) . to_bools ()) . to_vec () } Self :: Boot => { rhdl :: core :: bitx_vec (& rhdl :: bits :: bits :: < 3 > (1i64 as u128) . to_bools ()) . to_vec () } Self :: Running => { rhdl :: core :: bitx_vec (& rhdl :: bits :: bits :: < 3 > (2i64 as u128) . to_bools ()) . to_vec () } Self :: Stop => { rhdl :: core :: bitx_vec (& rhdl :: bits :: bits :: < 3 > (3i64 as u128) . to_bools ()) . to_vec () } Self :: Boom => { rhdl :: core :: bitx_vec (& rhdl :: bits :: bits :: < 3 > (4i64 as u128) . to_bools ()) . to_vec () } Self :: Unknown => { rhdl :: core :: bitx_vec (& rhdl :: bits :: bits :: < 3 > (5i64 as u128) . to_bools ()) . to_vec () } } . to_vec () ; raw . resize (Self :: BITS , rhdl :: core :: BitX :: Zero) ; (rhdl :: core :: move_nbits_to_msb (& raw , 3usize)) . into () } fn discriminant (self) -> rhdl :: core :: TypedBits { match self { Self :: Init => { rhdl :: bits :: bits :: < 3 > (0i64 as u128) . typed_bits () } Self :: Boot => { rhdl :: bits :: bits :: < 3 > (1i64 as u128) . typed_bits () } Self :: Running => { rhdl :: bits :: bits :: < 3 > (2i64 as u128) . typed_bits () } Self :: Stop => { rhdl :: bits :: bits :: < 3 > (3i64 as u128) . typed_bits () } Self :: Boom => { rhdl :: bits :: bits :: < 3 > (4i64 as u128) . typed_bits () } Self :: Unknown => { rhdl :: bits :: bits :: < 3 > (5i64 as u128) . typed_bits () } } } fn variant_kind (self) -> rhdl :: core :: Kind { match self { Self :: Init => { rhdl :: core :: Kind :: Empty } Self :: Boot => { rhdl :: core :: Kind :: Empty } Self :: Running => { rhdl :: core :: Kind :: Empty } Self :: Stop => { rhdl :: core :: Kind :: Empty } Self :: Boom => { rhdl :: core :: Kind :: Empty } Self :: Unknown => { rhdl :: core :: Kind :: Empty } } } fn dont_care () -> Self { < Self as Default > :: default () } }