impl < const N : usize > rhdl :: core :: Synchronous for Strobe < N > { type S = (Self :: Q , < DFF < Bits < N > > as rhdl :: core :: Synchronous > :: S , < Constant < Bits < N > > as rhdl :: core :: Synchronous > :: S) ; fn init (& self) -> Self :: S { (<< Self as rhdl :: core :: SynchronousDQ > :: Q as rhdl :: core :: Digital > :: dont_care () , Synchronous :: init (& self . strobe) , Synchronous :: init (& self . value)) } fn children (& self , parent_scope : & rhdl :: core :: ScopedName) -> impl Iterator < Item = Result < rhdl :: core :: Descriptor < rhdl :: core :: SyncKind > , rhdl :: core :: RHDLError >> { [Synchronous :: descriptor (& self . strobe , parent_scope . with (stringify ! (strobe))) , Synchronous :: descriptor (& self . value , parent_scope . with (stringify ! (value)))] . into_iter () } fn sim (& self , clock_reset : rhdl :: core :: ClockReset , input : < Self as SynchronousIO > :: I , state : & mut Self :: S) -> < Self as SynchronousIO > :: O { let update_fn = << Self as SynchronousIO > :: Kernel as DigitalFn3 > :: func () ; rhdl :: core :: trace ("input" , & input) ; for _ in 0 .. rhdl :: core :: MAX_ITERS { let prev_state = state . clone () ; let (outputs , internal_inputs) = update_fn (clock_reset , input , state . 0) ; rhdl :: core :: trace_push_path (stringify ! (strobe)) ; state . 0. strobe = Synchronous :: sim (& self . strobe , clock_reset , internal_inputs . strobe , & mut state . 1) ; rhdl :: core :: trace_pop_path () ; rhdl :: core :: trace_push_path (stringify ! (value)) ; state . 0. value = Synchronous :: sim (& self . value , clock_reset , internal_inputs . value , & mut state . 2) ; rhdl :: core :: trace_pop_path () ; if state == & prev_state { rhdl :: core :: trace ("outputs" , & outputs) ; return outputs ; } } panic ! ("Simulation did not converge") ; } }