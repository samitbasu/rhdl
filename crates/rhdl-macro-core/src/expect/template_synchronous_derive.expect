impl < const N : usize > rhdl :: core :: Synchronous for Strobe < N > { type S = (Self :: Q , < DFF < Bits < N > > as rhdl :: core :: Synchronous > :: S , < Constant < Bits < N > > as rhdl :: core :: Synchronous > :: S) ; fn init (& self) -> Self :: S { (<< Self as rhdl :: core :: SynchronousDQ > :: Q as rhdl :: core :: Digital > :: dont_care () , self . strobe . init () , self . value . init () ,) } fn descriptor (& self , name : & str) -> Result < rhdl :: core :: CircuitDescriptor , rhdl :: core :: RHDLError > { use std :: collections :: BTreeMap ; let mut children : BTreeMap < String , CircuitDescriptor > = BTreeMap :: new () ; children . insert (stringify ! (strobe) . to_string () , self . strobe . descriptor (& format ! ("{name}_{}" , stringify ! (strobe))) ?) ; children . insert (stringify ! (value) . to_string () , self . value . descriptor (& format ! ("{name}_{}" , stringify ! (value))) ?) ; rhdl :: core :: build_synchronous_descriptor :: < Self > (name , children) } fn hdl (& self , name : & str) -> Result < rhdl :: core :: HDLDescriptor , rhdl :: core :: RHDLError > { use std :: collections :: BTreeMap ; let mut children : BTreeMap < String , HDLDescriptor > = BTreeMap :: new () ; children . insert (stringify ! (strobe) . to_string () , self . strobe . hdl (& format ! ("{name}_{}" , stringify ! (strobe))) ?) ; children . insert (stringify ! (value) . to_string () , self . value . hdl (& format ! ("{name}_{}" , stringify ! (value))) ?) ; rhdl :: core :: build_synchronous_hdl (self , name , children) } fn sim (& self , clock_reset : rhdl :: core :: ClockReset , input : < Self as SynchronousIO > :: I , state : & mut Self :: S) -> < Self as SynchronousIO > :: O { let update_fn = << Self as SynchronousIO > :: Kernel as DigitalFn3 > :: func () ; rhdl :: core :: trace ("input" , & input) ; for _ in 0 .. rhdl :: core :: MAX_ITERS { let prev_state = state . clone () ; let (outputs , internal_inputs) = update_fn (clock_reset , input , state . 0) ; rhdl :: core :: trace_push_path (stringify ! (strobe)) ; state . 0. strobe = self . strobe . sim (clock_reset , internal_inputs . strobe , & mut state . 1) ; rhdl :: core :: trace_pop_path () ; rhdl :: core :: trace_push_path (stringify ! (value)) ; state . 0. value = self . value . sim (clock_reset , internal_inputs . value , & mut state . 2) ; rhdl :: core :: trace_pop_path () ; if state == & prev_state { rhdl :: core :: trace ("outputs" , & outputs) ; return outputs ; } } panic ! ("Simulation did not converge") ; } }