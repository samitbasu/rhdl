impl rhdl::core::Circuit for Push {
    type S = (
        Self::Q,
        <Strobe<32> as rhdl::core::Circuit>::S,
        <Constant<Bits<8>> as rhdl::core::Circuit>::S,
        <ZDriver<8> as rhdl::core::Circuit>::S,
        <DFF<Side> as rhdl::core::Circuit>::S,
        <DFF<Bits<8>> as rhdl::core::Circuit>::S,
    );
    fn init(&self) -> Self::S {
        (
            <<Self as rhdl::core::CircuitDQ>::Q as rhdl::core::Digital>::dont_care(),
            Circuit::init(&self.strobe),
            Circuit::init(&self.value),
            Circuit::init(&self.buf_z),
            Circuit::init(&self.side),
            Circuit::init(&self.latch),
        )
    }
    fn children(
        &self,
        parent_scope: &rhdl::core::ScopedName,
    ) -> impl Iterator<
        Item = Result<
            rhdl::core::Descriptor<rhdl::core::AsyncKind>,
            rhdl::core::RHDLError,
        >,
    > {
        [
            Circuit::descriptor(&self.strobe, parent_scope.with(stringify!(strobe))),
            Circuit::descriptor(&self.value, parent_scope.with(stringify!(value))),
            Circuit::descriptor(&self.buf_z, parent_scope.with(stringify!(buf_z))),
            Circuit::descriptor(&self.side, parent_scope.with(stringify!(side))),
            Circuit::descriptor(&self.latch, parent_scope.with(stringify!(latch))),
        ]
            .into_iter()
    }
    fn sim(
        &self,
        input: <Self as rhdl::core::CircuitIO>::I,
        state: &mut Self::S,
    ) -> <Self as CircuitIO>::O {
        let update_fn = <<Self as rhdl::core::CircuitIO>::Kernel as rhdl::core::DigitalFn2>::func();
        rhdl::core::trace("input", &input);
        for _ in 0..rhdl::core::MAX_ITERS {
            let prev_state = state.clone();
            let (outputs, internal_inputs) = update_fn(input, state.0);
            rhdl::core::trace_push_path(stringify!(strobe));
            state.0.strobe = Circuit::sim(
                &self.strobe,
                internal_inputs.strobe,
                &mut state.1,
            );
            rhdl::core::trace_pop_path();
            rhdl::core::trace_push_path(stringify!(value));
            state.0.value = Circuit::sim(
                &self.value,
                internal_inputs.value,
                &mut state.2,
            );
            rhdl::core::trace_pop_path();
            rhdl::core::trace_push_path(stringify!(buf_z));
            state.0.buf_z = Circuit::sim(
                &self.buf_z,
                internal_inputs.buf_z,
                &mut state.3,
            );
            rhdl::core::trace_pop_path();
            rhdl::core::trace_push_path(stringify!(side));
            state.0.side = Circuit::sim(&self.side, internal_inputs.side, &mut state.4);
            rhdl::core::trace_pop_path();
            rhdl::core::trace_push_path(stringify!(latch));
            state.0.latch = Circuit::sim(
                &self.latch,
                internal_inputs.latch,
                &mut state.5,
            );
            rhdl::core::trace_pop_path();
            if state == &prev_state {
                rhdl::core::trace("outputs", &outputs);
                return outputs;
            }
        }
        panic!("Simulation did not converge");
    }
}
