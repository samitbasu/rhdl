impl rhdl :: core :: Synchronous for Push { type S = (Self :: Q , < Strobe < 32 > as rhdl :: core :: Synchronous > :: S , < Constant < Bits < 8 > > as rhdl :: core :: Synchronous > :: S , < ZDriver < 8 > as rhdl :: core :: Synchronous > :: S , < DFF < Side > as rhdl :: core :: Synchronous > :: S , < DFF < Bits < 8 > > as rhdl :: core :: Synchronous > :: S) ; fn init (& self) -> Self :: S { (<< Self as rhdl :: core :: SynchronousDQ > :: Q as rhdl :: core :: Digital > :: dont_care () , self . strobe . init () , self . value . init () , self . buf_z . init () , self . side . init () , self . latch . init ()) } fn children (& self , parent_scope : & rhdl :: core :: ScopedName) -> impl Iterator < Item = Result < rhdl :: core :: Descriptor , rhdl :: core :: RHDLError >> { [self . strobe . descriptor (parent_scope . with (stringify ! (strobe))) , self . value . descriptor (parent_scope . with (stringify ! (value))) , self . buf_z . descriptor (parent_scope . with (stringify ! (buf_z))) , self . side . descriptor (parent_scope . with (stringify ! (side))) , self . latch . descriptor (parent_scope . with (stringify ! (latch)))] . into_iter () } fn sim (& self , clock_reset : rhdl :: core :: ClockReset , input : < Self as SynchronousIO > :: I , state : & mut Self :: S) -> < Self as SynchronousIO > :: O { let update_fn = << Self as SynchronousIO > :: Kernel as DigitalFn3 > :: func () ; rhdl :: core :: trace ("input" , & input) ; for _ in 0 .. rhdl :: core :: MAX_ITERS { let prev_state = state . clone () ; let (outputs , internal_inputs) = update_fn (clock_reset , input , state . 0) ; rhdl :: core :: trace_push_path (stringify ! (strobe)) ; state . 0. strobe = self . strobe . sim (clock_reset , internal_inputs . strobe , & mut state . 1) ; rhdl :: core :: trace_pop_path () ; rhdl :: core :: trace_push_path (stringify ! (value)) ; state . 0. value = self . value . sim (clock_reset , internal_inputs . value , & mut state . 2) ; rhdl :: core :: trace_pop_path () ; rhdl :: core :: trace_push_path (stringify ! (buf_z)) ; state . 0. buf_z = self . buf_z . sim (clock_reset , internal_inputs . buf_z , & mut state . 3) ; rhdl :: core :: trace_pop_path () ; rhdl :: core :: trace_push_path (stringify ! (side)) ; state . 0. side = self . side . sim (clock_reset , internal_inputs . side , & mut state . 4) ; rhdl :: core :: trace_pop_path () ; rhdl :: core :: trace_push_path (stringify ! (latch)) ; state . 0. latch = self . latch . sim (clock_reset , internal_inputs . latch , & mut state . 5) ; rhdl :: core :: trace_pop_path () ; if state == & prev_state { rhdl :: core :: trace ("outputs" , & outputs) ; return outputs ; } } panic ! ("Simulation did not converge") ; } }