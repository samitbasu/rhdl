// Autogenerated testbench for dut
module testbench();
    wire [6:0] out;
    reg [4:0] arg_0;
    dut t (.out(out),.arg_0(arg_0));
    initial begin
        arg_0 = 5'b11100;
        #0;
        if (7'b1001100 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 0", 7'b1001100, out);
            $finish;
        end
        arg_0 = 5'b00000;
        #0;
        if (7'b1010000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 1", 7'b1010000, out);
            $finish;
        end
        arg_0 = 5'b00001;
        #0;
        if (7'b1100000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 2", 7'b1100000, out);
            $finish;
        end
        $display("TESTBENCH OK", );
        $finish;
    end
endmodule
//
module dut(input wire [4:0] arg_0, output reg [6:0] out);
    reg [0:0] r1;
    reg [0:0] r2;
    reg [0:0] r3;
    reg [0:0] r4;
    reg [0:0] r5;
    reg [0:0] r23;
    reg [0:0] r37;
    reg [0:0] r38;
    reg [0:0] r39;
    reg [0:0] r40;
    reg [0:0] r41;
    reg [0:0] r42;
    always @(*) begin
        r1 = arg_0[0];
        r2 = arg_0[1];
        r3 = arg_0[2];
        r4 = arg_0[3];
        r5 = arg_0[4];
        // let b = match a.val() {
        //    Ok(data, )#true => ReadResponse/* option::ReadResponse<rhdl::rhdl_typenum::consts::U4> */ {data: data, resp: ResponseCode :: OKAY,},
        //    Err(e, )#false => ReadResponse/* option::ReadResponse<rhdl::rhdl_typenum::consts::U4> */ {data: bits(0), resp: match e {
        //          const AXI4Error::SLVERR => ResponseCode :: SLVERR,
        //          const AXI4Error::DECERR => ResponseCode :: DECERR,
        //       },},
        // };
        //
        // signal(Some(b))
        //
        r23 = ~(r1);
        r37 = r5 & r1;
        r38 = r5 & r2;
        r39 = r5 & r3;
        r40 = r5 & r4;
        r42 = (r5) ? (1'b0) : (r1);
        r41 = (r5) ? (1'b0) : (r23);
        out = { 1'b1, r42, r41, r40, r39, r38, r37 };
    end
endmodule
