// Autogenerated testbench for dut
module testbench();
    wire [17:0] out;
    reg [23:0] arg_0;
    reg [10:0] arg_1;
    dut t (.out(out),.arg_0(arg_0),.arg_1(arg_1));
    initial begin
        arg_0 = 24'b000000000000001000000001;
        arg_1 = 11'b00000000000;
        #0;
        if (18'b000001100000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 0", 18'b000001100000000000, out);
            $finish;
        end
        arg_0 = 24'b000000000000001000000001;
        arg_1 = 11'b11000000000;
        #0;
        if (18'b000001100000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 1", 18'b000001100000000000, out);
            $finish;
        end
        arg_0 = 24'b000000000000001000000001;
        arg_1 = 11'b01000100001;
        #0;
        if (18'b000001100000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 2", 18'b000001100000000000, out);
            $finish;
        end
        arg_0 = 24'b000000000000001000000001;
        arg_1 = 11'b10000000011;
        #0;
        if (18'b000001100000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 3", 18'b000001100000000000, out);
            $finish;
        end
        arg_0 = 24'b010000000001001000000001;
        arg_1 = 11'b00000000000;
        #0;
        if (18'b000001100000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 4", 18'b000001100000000000, out);
            $finish;
        end
        arg_0 = 24'b010000000001001000000001;
        arg_1 = 11'b11000000000;
        #0;
        if (18'b000001100000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 5", 18'b000001100000000000, out);
            $finish;
        end
        arg_0 = 24'b010000000001001000000001;
        arg_1 = 11'b01000100001;
        #0;
        if (18'b000001100000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 6", 18'b000001100000000000, out);
            $finish;
        end
        arg_0 = 24'b010000000001001000000001;
        arg_1 = 11'b10000000011;
        #0;
        if (18'b000001100000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 7", 18'b000001100000000000, out);
            $finish;
        end
        arg_0 = 24'b100000100001001000000001;
        arg_1 = 11'b00000000000;
        #0;
        if (18'b000001100000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 8", 18'b000001100000000000, out);
            $finish;
        end
        arg_0 = 24'b100000100001001000000001;
        arg_1 = 11'b11000000000;
        #0;
        if (18'b000001100000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 9", 18'b000001100000000000, out);
            $finish;
        end
        arg_0 = 24'b100000100001001000000001;
        arg_1 = 11'b01000100001;
        #0;
        if (18'b000001100000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 10", 18'b000001100000000000, out);
            $finish;
        end
        arg_0 = 24'b100000100001001000000001;
        arg_1 = 11'b10000000011;
        #0;
        if (18'b000001100000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 11", 18'b000001100000000000, out);
            $finish;
        end
        $display("TESTBENCH OK", );
        $finish;
    end
endmodule
//
module dut(input wire [23:0] arg_0, input wire [10:0] arg_1, output reg [17:0] out);
    reg [0:0] r18;
    reg [0:0] r19;
    reg [0:0] r20;
    reg [0:0] r21;
    reg [0:0] r22;
    reg [0:0] r23;
    reg [0:0] r24;
    reg [0:0] r25;
    reg [0:0] r26;
    reg [0:0] r27;
    reg [0:0] r28;
    reg [0:0] r29;
    reg [0:0] r30;
    reg [0:0] r31;
    reg [0:0] r32;
    reg [0:0] r33;
    reg [0:0] r34;
    reg [0:0] r35;
    reg [0:0] r36;
    reg [0:0] r37;
    reg [0:0] r38;
    reg [0:0] r39;
    reg [0:0] r40;
    reg [0:0] r41;
    reg [0:0] r42;
    reg [0:0] r43;
    reg [0:0] r44;
    reg [0:0] r45;
    reg [0:0] r46;
    reg [0:0] r47;
    reg [0:0] r48;
    reg [0:0] r49;
    reg [0:0] r50;
    reg [0:0] r51;
    reg [0:0] r52;
    initial begin
        r18 = arg_0[0];
        r19 = arg_0[1];
        r20 = arg_0[2];
        r21 = arg_0[3];
        r22 = arg_0[4];
        r23 = arg_0[5];
        r24 = arg_0[6];
        r25 = arg_0[7];
        r26 = arg_0[8];
        r27 = arg_0[9];
        r28 = arg_0[10];
        r29 = arg_0[11];
        r30 = arg_0[12];
        r31 = arg_0[13];
        r32 = arg_0[14];
        r33 = arg_0[15];
        r34 = arg_0[16];
        r35 = arg_0[17];
        r36 = arg_0[18];
        r37 = arg_0[19];
        r38 = arg_0[20];
        r39 = arg_0[21];
        r40 = arg_0[22];
        r41 = arg_0[23];
        r42 = arg_1[0];
        r43 = arg_1[1];
        r44 = arg_1[2];
        r45 = arg_1[3];
        r46 = arg_1[4];
        r47 = arg_1[5];
        r48 = arg_1[6];
        r49 = arg_1[7];
        r50 = arg_1[8];
        r51 = arg_1[9];
        r52 = arg_1[10];
        // let _z = (a.val().b, a.val().a + MY_SPECIAL_NUMBER, );
        //
        // let foo = bits(6);
        //
        // let _foo2 = foo + foo;
        //
        // let _c = a;
        //
        // let q = signed(2);
        //
        // let _q = Foo/* adt::Foo */ {a: bits(1), b: q, c: Rad :: A,};
        //
        // signal((NooState :: Init, bits(3), ))
        //
        out = { 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b1, 1'b1, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0 };
    end
endmodule
