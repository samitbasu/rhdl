// Autogenerated testbench for kernel_do_stuff
module testbench();
    wire [17:0] out;
    reg [23:0] arg_0;
    reg [10:0] arg_1;
    assign out = kernel_do_stuff(arg_0, arg_1);
    initial begin
        arg_0 = 24'b000000000000001000000001;
        arg_1 = 11'b00000000000;
        #0;
        if (18'b010101001000100001 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 0", 18'b010101001000100001, out);
            $finish;
        end
        arg_0 = 24'b000000000000001000000001;
        arg_1 = 11'b11000000000;
        #0;
        if (18'b010101000000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 1", 18'b010101000000000000, out);
            $finish;
        end
        arg_0 = 24'b000000000000001000000001;
        arg_1 = 11'b01000100001;
        #0;
        if (18'b010101010000000101 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 2", 18'b010101010000000101, out);
            $finish;
        end
        arg_0 = 24'b000000000000001000000001;
        arg_1 = 11'b10000000011;
        #0;
        if (18'b010101011000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 3", 18'b010101011000000000, out);
            $finish;
        end
        arg_0 = 24'b010000000001001000000001;
        arg_1 = 11'b00000000000;
        #0;
        if (18'b010101001000100001 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 4", 18'b010101001000100001, out);
            $finish;
        end
        arg_0 = 24'b010000000001001000000001;
        arg_1 = 11'b11000000000;
        #0;
        if (18'b010101000000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 5", 18'b010101000000000000, out);
            $finish;
        end
        arg_0 = 24'b010000000001001000000001;
        arg_1 = 11'b01000100001;
        #0;
        if (18'b010101010000000101 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 6", 18'b010101010000000101, out);
            $finish;
        end
        arg_0 = 24'b010000000001001000000001;
        arg_1 = 11'b10000000011;
        #0;
        if (18'b010101011000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 7", 18'b010101011000000000, out);
            $finish;
        end
        arg_0 = 24'b100000100001001000000001;
        arg_1 = 11'b00000000000;
        #0;
        if (18'b010101001000100001 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 8", 18'b010101001000100001, out);
            $finish;
        end
        arg_0 = 24'b100000100001001000000001;
        arg_1 = 11'b11000000000;
        #0;
        if (18'b010101000000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 9", 18'b010101000000000000, out);
            $finish;
        end
        arg_0 = 24'b100000100001001000000001;
        arg_1 = 11'b01000100001;
        #0;
        if (18'b010101010000000101 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 10", 18'b010101010000000101, out);
            $finish;
        end
        arg_0 = 24'b100000100001001000000001;
        arg_1 = 11'b10000000011;
        #0;
        if (18'b010101011000000000 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 11", 18'b010101011000000000, out);
            $finish;
        end
        $display("TESTBENCH OK", );
        $finish;
    end
    function [17:0] kernel_do_stuff(input reg [23:0] arg_0, input reg [10:0] arg_1);
        reg [23:0] or0;
        reg [7:0] or1;
        reg [0:0] or2;
        reg [17:0] or3;
        reg [0:0] or4;  // __$early_return_flag
        reg [17:0] or5;  // do_stuff
        reg [10:0] or6;
        reg [1:0] or7;
        reg [8:0] or8;
        reg [4:0] or9;
        reg [4:0] or10;
        reg [4:0] or11;
        reg [10:0] or12;
        reg [10:0] or13;
        reg [17:0] or14;
        reg [17:0] or15;  // do_stuff
        localparam ol0 = 8'b00001100;
        localparam ol1 = 18'b000001111000000000;
        localparam ol2 = 1'b1;
        localparam ol3 = 1'b0;
        localparam ol4 = 18'b000000000000000000;
        localparam ol5 = 5'b00011;
        localparam ol6 = 11'b10000000000;
        localparam ol7 = 2'b00;
        localparam ol8 = 11'b01000100001;
        localparam ol9 = 2'b01;
        localparam ol10 = 2'b10;
        localparam ol11 = 11'b11000000000;
        localparam ol12 = 2'b11;
        localparam ol13 = 11'b00000000000;
        localparam ol14 = 7'b0101010;
        begin
            or0 = arg_0;
            or6 = arg_1;
            // let a = a.val();
            //
            // let _z = (a.b, a.a + MY_SPECIAL_NUMBER, );
            //
            // let foo = bits(6);
            //
            // let _foo2 = foo + foo;
            //
            // let _c = a;
            //
            // let q = signed(2);
            //
            // let _q = Foo/* adt::Foo */ {a: bits(1), b: q, c: Rad :: A,};
            //
            // let c = Rad :: A;
            //
            // let _d = c;
            //
            // let _z = fifo(signal(bits(3)), signal(bits(5)));
            //
            // let q = bits(1);
            //
            // let _l = q.any();
            //
            // q |= bits(1 << 3);
            //
            // let _p = (q & bits(1 << 2)).any();
            //
            // let _p = q.as_signed();
            //
            // if a.a > bits(12) {
            //    return signal((NooState :: Boom, bits(3), ));
            // }
            //
            //
            or1 = or0[7:0];
            or2 = or1 > ol0;
            // return signal((NooState :: Boom, bits(3), ));
            //
            or3 = ol1;
            or4 = (or2) ? (ol2) : (ol3);
            or5 = (or2) ? (or3) : (ol4);
            // let _e = Rad::B(q);
            //
            // let x1 = bits(4);
            //
            // let y1 = bits(6);
            //
            // let ar = [bits(1), bits(1), bits(3), ];
            //
            // ar[1] = bits(2);
            //
            // let _z: [b4; 3] = ar;
            //
            // let _q = ar[1];
            //
            // let f: [b4; 5] = [bits(1); 5];
            //
            // let _h = f[2];
            //
            // let _k = NooState :: Init;
            //
            // let _f = Rad::C/* adt::Rad */ {y: y1, x: x1,};
            //
            // let d = match s.val() {
            //    const NooState::Init => NooState::Run(bits(1), bits(2)),
            //    NooState::Run(_x, y, )#1_b2 => NooState::Walk/* adt::NooState */ {foo: (y + 3).resize(),},
            //    NooState::Walk {foo: x,}#2_b2 => {
            //       let _q = bits(1) + x;
            //       NooState :: Boom
            //    }
            //    ,
            //    const NooState::Boom => NooState :: Init,
            // };
            //
            or7 = or6[10:9];
            or8 = or6[8:0];
            or9 = or8[8:4];
            or10 = or9 + ol5;
            or11 = or10[4:0];
            or12 = ol6; or12[4:0] = or11;
            // let _q = bits(1) + x;
            //
            // NooState :: Boom
            //
            case (or7)
                2'b00: or13 = ol8;
                2'b01: or13 = or12;
                2'b10: or13 = ol11;
                2'b11: or13 = ol13;
            endcase
            // let k = 42;
            //
            // signal((d, bits(k), ))
            //
            or14 = { ol14, or13 };
            or15 = (or4) ? (or5) : (or14);
            kernel_do_stuff = or15;
        end
    endfunction
endmodule
