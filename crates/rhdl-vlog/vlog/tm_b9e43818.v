// Autogenerated testbench for dut
module testbench();
    wire [7:0] out;
    reg [3:0] arg_0;
    dut t (.out(out),.arg_0(arg_0));
    initial begin
        arg_0 = 4'b0000;
        #0;
        if (8'b00000110 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 0", 8'b00000110, out);
            $finish;
        end
        arg_0 = 4'b0001;
        #0;
        if (8'b00000110 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 1", 8'b00000110, out);
            $finish;
        end
        arg_0 = 4'b0010;
        #0;
        if (8'b00000110 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 2", 8'b00000110, out);
            $finish;
        end
        arg_0 = 4'b0011;
        #0;
        if (8'b00000110 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 3", 8'b00000110, out);
            $finish;
        end
        arg_0 = 4'b0100;
        #0;
        if (8'b00000110 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 4", 8'b00000110, out);
            $finish;
        end
        arg_0 = 4'b0101;
        #0;
        if (8'b00000110 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 5", 8'b00000110, out);
            $finish;
        end
        arg_0 = 4'b0110;
        #0;
        if (8'b00000110 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 6", 8'b00000110, out);
            $finish;
        end
        arg_0 = 4'b0111;
        #0;
        if (8'b00000110 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 7", 8'b00000110, out);
            $finish;
        end
        arg_0 = 4'b1000;
        #0;
        if (8'b00000110 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 8", 8'b00000110, out);
            $finish;
        end
        arg_0 = 4'b1001;
        #0;
        if (8'b00000110 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 9", 8'b00000110, out);
            $finish;
        end
        arg_0 = 4'b1010;
        #0;
        if (8'b00000110 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 10", 8'b00000110, out);
            $finish;
        end
        arg_0 = 4'b1011;
        #0;
        if (8'b00000110 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 11", 8'b00000110, out);
            $finish;
        end
        arg_0 = 4'b1100;
        #0;
        if (8'b00000110 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 12", 8'b00000110, out);
            $finish;
        end
        arg_0 = 4'b1101;
        #0;
        if (8'b00000110 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 13", 8'b00000110, out);
            $finish;
        end
        arg_0 = 4'b1110;
        #0;
        if (8'b00000110 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 14", 8'b00000110, out);
            $finish;
        end
        arg_0 = 4'b1111;
        #0;
        if (8'b00000110 !== out) begin
            $display("ASSERTION FAILED 0x%0h !== 0x%0h CASE 15", 8'b00000110, out);
            $finish;
        end
        $display("TESTBENCH OK", );
        $finish;
    end
endmodule
//
module dut(input wire [3:0] arg_0, output reg [7:0] out);
    reg [0:0] r8;
    reg [0:0] r9;
    reg [0:0] r10;
    reg [0:0] r11;
    initial begin
        r8 = arg_0[0];
        r9 = arg_0[1];
        r10 = arg_0[2];
        r11 = arg_0[3];
        // let a = arg.val();
        //
        // let b = !a;
        //
        // let c = a + b - 1;
        //
        // let q = (a, b, c, );
        //
        // let (_a, _b, _c, ) = q;
        //
        // let h = Bar(bits(1), bits(2));
        //
        // let _i = h.0;
        //
        // let Bar(_j, _k, ) = h;
        //
        // let _d = [1, 2, 3, ];
        //
        // let d = Foo/* ast::Foo */ {a: bits(1), b: bits(2), c: [bits(1), bits(2), bits(3), ],};
        //
        // let _p = Foo/* ast::Foo */ {a: bits(4), ..d};
        //
        // let _h = {
        //    let e = 3;
        //    let f = 4;
        //    bits(e) + bits(f)
        // }
        // ;
        //
        // let e = 3;
        //
        // let f = 4;
        //
        // bits(e) + bits(f)
        //
        // let Foo {a: a, b: b,} = d;
        //
        // let g = d.c[1];
        //
        // let e = d.a;
        //
        // {
        // }
        // ;
        //
        // let d: b8 = bits(7);
        //
        // if d > bits(0) {
        //    d -= 1;
        //    return signal(d);
        // }
        //
        //
        // d -= 1;
        //
        // return signal(d);
        //
        // let _j = if d < bits(3) {
        //    7
        // }
        //  else {
        //    9
        // }
        // ;
        //
        // 7
        //
        // 9
        //
        // let k = State :: Boom;
        //
        // let l = State::Run(bits(3));
        //
        // let j = match l {
        //    const State::Init => bits(1),
        //    State::Run(_a, )#1_b2 => bits(2),
        //    const State::Boom => bits(3),
        //    _ => bits(4),
        // };
        //
        // {
        // }
        // ;
        //
        // for ndx in 0..8 {
        //    d = (d + bits(ndx)).resize();
        // }
        //
        //
        // d = (d + bits(ndx)).resize();
        //
        // d = (d + bits(ndx)).resize();
        //
        // d = (d + bits(ndx)).resize();
        //
        // d = (d + bits(ndx)).resize();
        //
        // d = (d + bits(ndx)).resize();
        //
        // d = (d + bits(ndx)).resize();
        //
        // d = (d + bits(ndx)).resize();
        //
        // d = (d + bits(ndx)).resize();
        //
        // signal(bits(42))
        //
        out = { 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b1, 1'b1, 1'b0 };
    end
endmodule
