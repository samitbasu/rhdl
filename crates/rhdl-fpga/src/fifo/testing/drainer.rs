//! A burst FIFO drainer.
//! Uses the same sequence as a matching FIFO filler to check that the
//! values returned from the FIFO are the same ones generated by the writer.
use rhdl::prelude::*;

use crate::core::{constant, dff, option::unpack, slice::lsbs};

#[derive(Clone, Debug, Synchronous, SynchronousDQ)]
/// The core that provides the FIFO drainer
pub struct FIFODrainer<N: BitWidth> {
    _marker: constant::Constant<Bits<N>>,
    rng: crate::rng::xorshift::XorShift,
    sleep_counter: dff::DFF<Bits<U4>>,
    sleep_len: constant::Constant<Bits<U4>>,
    read_probability: constant::Constant<Bits<U16>>,
    valid: dff::DFF<bool>,
}

impl<N: BitWidth> Default for FIFODrainer<N> {
    fn default() -> Self {
        Self {
            _marker: constant::Constant::new(bits(0)),
            rng: crate::rng::xorshift::XorShift::default(),
            sleep_counter: dff::DFF::new(bits(0)),
            sleep_len: constant::Constant::new(bits(4)),
            read_probability: constant::Constant::new(bits(0xD000)),
            valid: dff::DFF::new(true),
        }
    }
}

impl<N: BitWidth> FIFODrainer<N> {
    /// Create a new [FIFODrainer] that will read with
    /// probability `read_probability` and will otherwise
    /// sleep for `sleep_len` clocks.
    pub fn new(sleep_len: u8, read_probability: f32) -> Self {
        let read_probability = 65535.0 * read_probability;
        Self {
            sleep_counter: dff::DFF::new(bits(0)),
            sleep_len: constant::Constant::new(bits(sleep_len as u128)),
            read_probability: constant::Constant::new(bits(read_probability as u128)),
            valid: dff::DFF::new(true),
            ..Default::default()
        }
    }
}

#[derive(PartialEq, Debug, Digital)]
/// Inputs for the [FIFODrainer] - should be attached to
/// an [Option] based FIFO interface
pub struct In<N: BitWidth> {
    /// The data elements consumed by the drainer
    pub data: Option<Bits<N>>,
}

#[derive(PartialEq, Debug, Digital)]
/// Outputs from the [FIFODrainer]
pub struct Out {
    /// Next signal to advance the FIFO
    pub next: bool,
    /// Valid check flag - will remain true as
    /// long as the received data is valid
    pub valid: bool,
}

impl<N: BitWidth> SynchronousIO for FIFODrainer<N> {
    type I = In<N>;
    type O = Out;
    type Kernel = drain_kernel<N>;
}

#[kernel]
#[doc(hidden)]
pub fn drain_kernel<N: BitWidth>(cr: ClockReset, input: In<N>, q: Q<N>) -> (Out, D<N>) {
    let mut d = D::<N>::dont_care();
    let mut o = Out::dont_care();
    // Compute an is-valid bit that is latching
    let was_valid = q.valid || cr.reset.any();
    // By default, the valid bit is latching
    d.valid = was_valid;
    // If there is data available and we are not sleeping, then read the next
    // value.  Validate against the RNG, and advance the rNG
    let (data_available, data) = unpack::<Bits<N>>(input.data, bits(0));
    let validation = lsbs::<N, U32>(q.rng);
    let data_matches = data == validation;
    let will_read = data_available && q.sleep_counter == 0;
    trace("data", &data);
    trace("validation", &validation);
    trace("data_matches", &data_matches);
    trace("will_read", &will_read);
    o.valid = was_valid;
    o.next = false;
    d.rng = false;
    d.sleep_counter = q.sleep_counter;
    if will_read {
        d.rng = true;
        o.next = true;
        d.valid = data_matches && was_valid;
        let p = lsbs::<U16, U32>(q.rng);
        d.sleep_counter = if p > q.read_probability {
            q.sleep_len
        } else {
            bits(0)
        }
    }
    if q.sleep_counter != 0 {
        d.sleep_counter = q.sleep_counter - 1;
    }
    if cr.reset.any() {
        d.valid = true;
        o.next = false;
        o.valid = true;
    }
    (o, d)
}

#[cfg(test)]
mod tests {

    use rhdl::core::sim::ResetOrData;

    use super::*;

    #[test]
    fn test_drainer_validation_works() {
        let uut = FIFODrainer::<U16>::default();
        let mut need_reset = true;
        let mut xorshift = crate::rng::xorshift::XorShift128::default();
        let mut rng_out = xorshift.next().unwrap();
        let mut counter = 0;
        let valid = uut
            .run_fn(
                |output| {
                    if need_reset {
                        need_reset = false;
                        return Some(ResetOrData::Reset);
                    }
                    if output.next {
                        rng_out = xorshift.next().unwrap();
                        counter += 1;
                        if counter == 4 {
                            rng_out = 0;
                        }
                    }
                    let next_input = In {
                        data: Some(b16((rng_out & 0xFFFF) as u128)),
                    };
                    Some(ResetOrData::Data(next_input))
                },
                100,
            )
            .take(100)
            .synchronous_sample()
            .map(|x| x.value.2.valid)
            .last()
            .unwrap();
        assert!(!valid);
    }

    #[test]
    fn test_drainer() {
        let uut = FIFODrainer::<U16>::default();
        let mut need_reset = true;
        let mut xorshift = crate::rng::xorshift::XorShift128::default();
        let mut rng_out = xorshift.next().unwrap();
        let valid = uut
            .run_fn(
                |output| {
                    if need_reset {
                        need_reset = false;
                        return Some(ResetOrData::Reset);
                    }
                    if output.next {
                        rng_out = xorshift.next().unwrap();
                    }
                    let next_input = Some(b16((rng_out & 0xFFFF) as u128));
                    Some(ResetOrData::Data(In { data: next_input }))
                },
                100,
            )
            .take(100)
            .synchronous_sample()
            .map(|x| x.value.2.valid)
            .last()
            .unwrap();
        assert!(valid);
    }

    #[test]
    fn test_drainer_hdl() -> miette::Result<()> {
        let uut = FIFODrainer::<U16>::default();
        let mut need_reset = true;
        let mut xorshift = crate::rng::xorshift::XorShift128::default();
        let mut rng_out = xorshift.next().unwrap();
        let test_bench = uut
            .run_fn(
                |output| {
                    if need_reset {
                        need_reset = false;
                        return Some(ResetOrData::Reset);
                    }
                    if output.next {
                        rng_out = xorshift.next().unwrap();
                    }
                    let next_input = Some(b16((rng_out & 0xFFFF) as u128));
                    Some(ResetOrData::Data(In { data: next_input }))
                },
                100,
            )
            .take(100)
            .collect::<SynchronousTestBench<_, _>>();
        let tm = test_bench.rtl(&uut, &TestBenchOptions::default())?;
        tm.run_iverilog()?;
        let tm = test_bench.ntl(&uut, &TestBenchOptions::default())?;
        tm.run_iverilog()?;
        Ok(())
    }
}
