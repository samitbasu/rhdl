{ let arg0 = rhdl :: vlog :: Port { direction : rhdl :: vlog :: Direction :: Input , decl : rhdl :: vlog :: Declaration { kind : rhdl :: vlog :: HDLKind :: Wire , signed_width : rhdl :: vlog :: SignedWidth :: Unsigned (0 ..= 2) , name : stringify ! (clock_reset) . into () } , } ; let arg1 = rhdl :: vlog :: Port { direction : rhdl :: vlog :: Direction :: Input , decl : rhdl :: vlog :: Declaration { kind : rhdl :: vlog :: HDLKind :: Wire , signed_width : rhdl :: vlog :: SignedWidth :: Unsigned (0 ..= 7) , name : stringify ! (i) . into () } , } ; let arg2 = rhdl :: vlog :: Port { direction : rhdl :: vlog :: Direction :: Output , decl : rhdl :: vlog :: Declaration { kind : rhdl :: vlog :: HDLKind :: Wire , signed_width : rhdl :: vlog :: SignedWidth :: Unsigned (0 ..= 7) , name : stringify ! (o) . into () } , } ; let args_vec = vec ! [arg0 , arg1 , arg2 ,] ; let item0 = rhdl :: vlog :: Item :: Declaration (rhdl :: vlog :: Declaration { kind : rhdl :: vlog :: HDLKind :: Wire , signed_width : rhdl :: vlog :: SignedWidth :: Unsigned (0 ..= 0) , name : stringify ! (clock) . into () }) ; let item1 = rhdl :: vlog :: Item :: Declaration (rhdl :: vlog :: Declaration { kind : rhdl :: vlog :: HDLKind :: Wire , signed_width : rhdl :: vlog :: SignedWidth :: Unsigned (0 ..= 0) , name : stringify ! (reset) . into () }) ; let item2 = rhdl :: vlog :: Item :: Statement (rhdl :: vlog :: Stmt :: ContinuousAssign (rhdl :: vlog :: Assign { target : stringify ! (clock) . into () , rhs : Box :: new (rhdl :: vlog :: Expr :: Index (rhdl :: vlog :: ExprIndex { target : stringify ! (clock_reset) . into () , address : rhdl :: vlog :: ExprIndexAddress { msb : Box :: new (rhdl :: vlog :: Expr :: Literal (0)) , lsb : . map (Box :: new) , } , })) , })) ; let item3 = rhdl :: vlog :: Item :: Statement (rhdl :: vlog :: Stmt :: ContinuousAssign (rhdl :: vlog :: Assign { target : stringify ! (wire) . into () , rhs : Box :: new (rhdl :: vlog :: Expr :: Index (rhdl :: vlog :: ExprIndex { target : stringify ! (clock_reset) . into () , address : rhdl :: vlog :: ExprIndexAddress { msb : Box :: new (rhdl :: vlog :: Expr :: Literal (1)) , lsb : . map (Box :: new) , } , })) , })) ; let item4 = rhdl :: vlog :: Item :: Statement (rhdl :: vlog :: Stmt :: Always (rhdl :: vlog :: Always { sensitivity : vec ! [rhdl :: vlog :: Sensitivity :: PosEdge (stringify ! (clock) . into ())] , body : Box :: new (rhdl :: vlog :: Stmt :: Block ({ let stmt0 = rhdl :: vlog :: Stmt :: If (rhdl :: vlog :: If { condition : Box :: new (rhdl :: vlog :: Expr :: Ident (stringify ! (reset) . into ())) , true_stmt : Box :: new (rhdl :: vlog :: Stmt :: Block ({ let stmt0 = rhdl :: vlog :: Stmt :: NonblockAssign (rhdl :: vlog :: Assign { target : stringify ! (o) . into () , rhs : Box :: new (rhdl :: vlog :: Expr :: Constant (rhdl :: vlog :: LitVerilog { width : 8 , value : stringify ! (b0) . into () , })) , }) ; vec ! [stmt0 ,] })) , else_branch : Some (Box :: new (rhdl :: vlog :: Stmt :: Block ({ let stmt0 = rhdl :: vlog :: Stmt :: NonblockAssign (rhdl :: vlog :: Assign { target : stringify ! (o) . into () , rhs : Box :: new (rhdl :: vlog :: Expr :: Ident (stringify ! (i) . into ())) , }) ; vec ! [stmt0 ,] }))) , }) ; vec ! [stmt0 ,] })) , })) ; let items_vec = vec ! [item0 , item1 , item2 , item3 , item4 ,] ; rhdl :: vlog :: ModuleDef { name : stringify ! (foo) . into () , args : args_vec , items : items_vec , } }