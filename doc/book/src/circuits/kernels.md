# Kernels

In the context of the `Circuit` trait, the compute kernel is specified in the `CircuitIO` trait.  Recall the `CircuitIO` trait

```rust
pub trait CircuitIO: 'static + CircuitDQ {
    type I: Timed;
    type O: Timed;
    type Kernel: DigitalFn + DigitalFn2<A0 = Self::I, A1 = Self::Q, O = (Self::O, Self::D)>;
}
```

The line of interest is this one:

```rust
type Kernel: DigitalFn + DigitalFn2<A0 = Self::I, A1 = Self::Q, O = (Self::O, Self::D)>;
```

which in words says that the `Kernel` type satisfies the following constraints

- `Kernel : DigitalFn` - this means that that `Kernel` is a synthesizable function that has been decorated with the `#[kernel]` attribute.
- `Kernel` is the type of a function that has the signature `fn(I, Q) -> (O, D)`.

An example is helpful.  In the [Half Adder](../half_adder/summary.md) section, we build a half adder that looks like this:

```badascii
              +---------+         
a +---+------>|         |         
      |       | XorGate +--> sum  
      |  +--->|         |         
      |  |    +---------+         
      |  |                        
      |  |                        
      |  |    +---------+         
      +-+|+-->|         |         
         |    | AndGate +--> carry
b +------+--->|         |         
              +---------+         
```

The output type for the circuit is defined as:

```rust
#[derive(Digital, Copy, Clone, Timed, PartialEq)]
pub struct Outputs {
    pub sum: Signal<bool, Red>,
    pub carry: Signal<bool, Red>,
}
```

The circuit itself is 

```rust
#[derive(Circuit, Clone)]
pub struct HalfAdder {
    xor: xor::XorGate,
    and: and::AndGate,
}
```

And the `CircuitIO` trait is defined as

```rust
impl CircuitIO for HalfAdder {
    type I = Signal<(bool, bool), Red>;
    type O = Outputs;
    type Kernel = half_adder;
}
```

For completeness, the `D` and `Q` types are defined explicitly in this case:

```rust
#[derive(Digital, Copy, Clone, Timed, PartialEq)]
pub struct D {
    xor: <xor::XorGate as CircuitIO>::I,
    and: <and::AndGate as CircuitIO>::I,
}
```

and the `Q` type must be defined as

```rust
#[derive(Digital, Copy, Clone, Timed, PartialEq)]
pub struct Q {
    xor: <xor::XorGate as CircuitIO>::O,
    and: <and::AndGate as CircuitIO>::O,
}
```

Finally, the `half_adder` kernel is defined as:

```rust
#[kernel]
pub fn half_adder(i: Signal<(bool, bool), Red>, q: Q) -> (Outputs, D) {
    // D is the set of inputs for the internal components
    let d = D {
        xor: i, 
        and: i, // ðŸ‘ˆ Digital : Copy, so no cloning needed
    };
    // Q is the output of those internal components
    let o = Outputs {
        sum: q.xor,
        carry: q.and,
    };
    (o, d)
}
```

Note the important things:

- The signature of the kernel is `fn(I, Q) -> (O, D)`.
- The `#[kernel]` attribute is attached to the definition.
- The name of the type and the name of the function are the same: `half_adder`. The type is automatically generated by RHDL.

Details about what subset of Rust is synthesizable are outlined in [Kernels](../kernels/summary.md).