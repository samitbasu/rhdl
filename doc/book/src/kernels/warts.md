# Warts and Footguns

The way that RHDL works is a bit complicated, and yet not complicated enough to make for a perfect end user experience.  Maybe some of these can be removed in the future, but for now, I prefer to at least list them.

## Enum Tuple Constructors

RHDL uses a trick to make synthesizable functions.  For any given function `foo` that is marked as `#[kernel]`, it will create a struct named `foo` that contains the meta data needed to compile `foo` into hardware.  You can do this because functions and structs occupy different namespaces.  The struct `foo` is a type and occupies "type space", and the function `foo` is a value, and occupies "value space".  This is all great when it works.  But there is one time when `rustc` makes use of this trick itself.  And that is in the constructors that are provided for tuple structs.  Consider, for example, the following code:

```rust
{{#rustdoc_include ../code/src/kernels/warts.rs:step_1}}
```

Here, the function `Color::Red` was auto-generated by the compiler.  Thus `Color` occupies "type" space, and the constructor function `Color::Red` occupies "value" space.  Now, we would like to make the function `Color::Red` synthesizable, but we cannot, because there is already an autogenerated function bound to that name in value space.

None of that is a problem theoretically, but in practice, we need to decide when processing the source code for your `kernel`, if a call like this:

```rust
{{#rustdoc_include ../code/src/kernels/warts.rs:step_2}}
```

constitutes a call to a built in constructor for the `Color::Red` variant, or if it is a call to a kernel named `Red` that resides in the `Color` module.    Furthermore, we need to make that decision at `proc-macro` time - so we have no idea what kind of type `Color` might be.  That information comes much later in the process.  Short of any other method to make this decision, we make the following assumption by convention:

```admonish warning
 If the name of the function is `Capitalized::Likethis`, then it is an enum constructor function, and we will assume that it must correspond to the `Likethis` variant of enum `Capitalized`.  That means, by the way, that you cannot call the constructor function as `x = Red(a)`, since we won't detect the constructor call without the `::` path separator.
 ```

To illustrate this wart, consider the following complelety valid Rust code:

```rust
{{#rustdoc_include ../code/src/kernels/warts.rs:step_3}}
```

If we attempt to compile it, though we get the following unintuitive error:

<!-- cmdrun to-html "cd ../code && cargo build --lib --features lowercase_enum 2>&1" -->



## Result and Option

There is partial support for `Result` and `Option` baked into RHDL, but the support is based on name matching and is not very robust.  So you can use constructs like

```rust
{{#rustdoc_include ../code/src/kernels/warts.rs:step_4}}
```

and RHDL will generally figure out the type of `Ok(x)` and `Err(y)`.  But it is not robust.  You can easily confuse the compiler which will either then require an explicit type signature at the call site (like `Result::<T, E>::Ok(x)`) or simply break when it goes to compile your function.  Type inference is very tricky given that RHDL makes most "decisions" about your source file at the time the macro is processed for the `#[kernel]` attribute, and has no context like type information, as that is all developed later.  There is a solution, which is to break the dependency on `rustc` and have RHDL be a completely stand-alone compiler.  But that seems like quite an effort.


## Partial Const Generic Support

It's quite frustrating that you can't do much with `const generic` type parameters, but that is the way it is.  For example, you would like to write something like:

```rust
{{#rustdoc_include ../code/src/kernels/warts.rs:step_5}}
```

But this requires unstable nightly features, and I simply don't want to go there. 

<!-- cmdrun to-html "cd ../code && cargo build --lib --features  const_generic_limits  2>&1" -->

For now, the workaround is to either use a macro to write the function (gross), or pass the responsibility to the caller (also gross), and then add an assertion to protect against incorrect use.  For the later approach, you might do:

```rust
{{#rustdoc_include ../code/src/kernels/warts.rs:step_6}}
```

