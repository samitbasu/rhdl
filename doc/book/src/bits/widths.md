# Bit Widths

In RHDL, the width of a bit vector (signed or unsigned) is a `const generic` parameter.  This means, you have a set of types such as `Bits<N>` where `N` is a `const usize` that determines the size of the bit vector at _compile time_.  Unfortunately, Rust support for const generics in stable is somewhat basic at the time I am writing this, and has remained so for a few years.  So there are a number of issues that arise in RHDL because of the lack of certain capabilities in stable rust:

1. You cannot write constraints on `const generic` parameters, so instead of a `where N >= 1 && N <= 128`, you need to write the somewhat less intuitive `where rhdl::bits::W<N>: BitWidth`, where `W` is zero-sized type provided by RHDL, and `BitWidth` is a marker trait.  This bound will only be valid if `N` is in the range `1..128`.  
2. You cannot "compute" sizes at compile time.  For example, if you have a bit vector of length `N`, and need to (generically) construct one of length `N+1`, well... Too bad.  This is somewhat frustrating, and there is no good work around at the moment.  All you can do is require that if `N` is generic, that `NP1` also be generic, and that you assert that `NP1 == N + 1` (you can do this with a const assert).  Similarly, if you have a bit-preserving operation, like multiplication of an `N` bit wide value with an `M` bit wide value, you cannot express via the type system that the result it `N+M` bits wide.
3. I did extensively experiment with `typenum` and even (at one point), built a completely functional typenum system based on the finite set of allowable bit values, but it was ungainly and slow.
4. As a result of the limitations of `const generic`s on stable rust, there are two additional types [DynBits] and [SignedDynBits], in which the widths are stored at _runtime_, and not at compile time.  Fortunately, the RHDL compiler can check your bit widths for you as it compiles your designs.  It's just one of those instances in which `rustc` will accept code that looks perfectly reasonable, but RHDL rejects because the bitwidths are not correct.

The other significant limitation is the fact that `N <= 128`.  If you want to manipulate larger bit vectors (like add 1024 bit integers, for example), you will need to write some custom blocks to perform the arithmetic or assemble them out of arithmetic on smaller vectors.  

But in short, there are 2 classes of bit vectors in RHDL:

1. The statically sized, compile-time vectors `Bits::<N>` and `SignedBits::<N>` where `N` is a `const usize`, and `N <=128`.  Due to a trait bound on these two types, you will need to constrain `N` anywhere you use it generically to satisfy `W<N>: BitWidth`.
2. The dynamically sized, run-time vectors `DynBits` and `SignedDynBits`, which store their size as a field at run time.  These are meant to be used with the extension operations, like `xadd` and `xmul`, when you need bit-widths to change based on the sizes of the arguments and are not working with all fixed-at-compile-time widths.  We will cover these in more detail later.