# Bit Widths

In RHDL, the width of a bit vector (signed or unsigned) is a `const generic` parameter.  This means, you have a set of types such as `Bits<N>` where `N` is a `const usize` that determines the size of the bit vector at _compile time_.  Unfortunately, Rust support for const generics in stable is somewhat basic at the time I am writing this, and has remained so for a few years.  So there are a number of issues that arise in RHDL because of the lack of certain capabilities in stable rust:

1. You cannot write constraints on `const generic` parameters, so instead of a `where N >= 1 && N <= 128`, you need to write the somewhat less intuitive `where W<N> : BitWidth`, where `W` is zero-sized type provided by RHDL, and `BitWidth` is a marker trait.  This bound will only be valid if `N` is in the range `1..128`.  
2. You cannot "compute" sizes at compile time.  For example, if you have a bit vector of length `N`, and need to (generically) construct one of length `N+1`, well... Too bad.  This is somewhat frustrating, and there is no good work around at the moment.  All you can do is require that if `N` is generic, that `NP1` also be generic, and that you assert that `NP1 == N + 1` (you can do this with a const assert).  Similarly, if you have a bit-preserving operation, like multiplication of an `N` bit wide value with an `M` bit wide value, you cannot express via the type system that the result it `N+M` bits wide.
3. I did extensively experiment with `typenum` and even (at one point), built a completely functional typenum system based on the finite set of allowable bit values, but it was ungainly and slow.
4. As a result of the limitations of `const generic`s on stable rust, there are two additional types [DynBits] and [SignedDynBits], in which the widths are stored at _runtime_, and not at compile time.  Fortunately, the RHDL compiler can check your bit widths for you as it compiles your designs.  It's just one of those instances in which `rustc` will accept code that looks perfectly reasonable, but RHDL rejects because the bitwidths are not correct.
