# Advanced

If you have worked with `rustc` long enough, you have run into situations in which the borrow checker is not able to reason about some borrow in your code, and you have to resort to runtime borrow checking (with an `Rc` and `RefCell` or `Arc` and `Mutex`).  In RHDL, we encounter a similar situation due to limitations of the current type system in stable Rust.  For example, we have already described how the bit width rules for addition are bit preserving: `N + N -> N`.  But what if we need the carry out bit?  To preserve information, the signature should really be `N + N -> (N+1)`.  Unfortunately, that is not really a function you can write.  And more generally, `N + M -> (N.max(M)+1)`, since adding two bit vectors of different width should (if all information is to be preserved) result in an output that is one bit larger than the larger of the two arguments.

At some point, I tried to code all this into the type system.  There were `typenum` number classes, and all kinds of constraints and bounds.  But ultimately, I kept running into a mix of limitations that made the end result unworkable.  So I decided to punt and hide the bit width from the type system, and move it to the runtime.  At least partly.  RHDL has its own compilation stage (several of them), and those compilers can track the bit width calculations as they flow through your design and ensure no bits are dropped or lost.  But `rustc` will be oblivious at compile time.  Just like the `Rc<RefCell>` pattern.

The pattern I used is also called `type erasure`.  We take a value with a compile-time defined bit width `N`, and convert it to a value that has a run-time defined bit width.  For an unsigned value, this conversion is `Bits<N> -> DynBits`.  And for signed values, this conversion is `SignedBits<N> -> SignedDynBits`.  There are some very important caveats on these type erased bit vectors that you should understand:

1. You cannot use `DynBits` or `SignedDynBits` as part of your "public" API.  That is to say, you cannot compose them into data structures that go "on the wire" or are passed in or out of your compute kernels.
2. Because you must ultimately convert `DynBits -> Bits<N>` to store or pass it on, you must ultimately know how many bits end up at the output of your calculations.  As a result, `DynBits` are best suited for scoped calculations where the bit width manipulation would be too tedius to explain to `rustc`, and where you know what the input and output bitwidths are going to be.
3. If you get it wrong, then you will get errors.  How soon you get the error is up to you.  We'll take a look at how to constrain designs that use dynamic bitvectors in the [Late Checking] section.
