# Synchronous Designs

Almost all of the real work done in digital designs will probably done using `Synchronous` circuits.  A synchronous circuit has the following properties (and we will cover it in detail later):

- All inputs and output belong to the same time domain
- A clock signal is provided and all inputs change only on the appropriate edge of that clock
- A reset signal is provided that asserts only on the appropriate edge of that clock

With these additional assumptions, we can remove the need to express time domains in our interfaces, and deal with a simpler syntax and mental model.  For example, in the [summary], we presented the following typical multi-domain design

```badascii
              +-------+-+----------+-+-------------+             
              |       | |          | |             |             
To/From +---->| Async |C|Core Logic|C| DRAM Driver +----> To/From
Reality <-----+       |D| 100 MHz  |D|   800MHz    |<---+  DRAM  
              |       |C|          |C|             |             
              +-------+-+----------+-+-------------+             
                  ^           ^            ^                     
                  +           +            +                     
                 Red        Green        Blue                    
```

where inputs coming from the outside world are marked as belonging to some `Red` time domain, and our core logic is in the `Green` domain.  If we were to look at that core logic more closely, we would see something like this:

```badascii
              +--+Core Logic+-------------+           
              | +----+                    |           
   From  Red  | |    |   +-------------+  |           
Reality +-----+>|sync+-->|             |  |           
              | |    |   | Synchronous |  |    To     
              | +----+   |   Core      +--+--> Reality
        Green |   ^      |   Logic     |  |           
  clock +-----+---+----->|             |  |           
              |          |             |  |           
  reset +-----+--------->|             |  |           
              |          +-------------+  |           
              +---------------------------+           
```

Here, we have a clock and reset signal generated by some circuitry (an oscillator), and our inputs coming from some non-timed `Red` domain.  A synchronizer of some kind makes those signals "safe" to use in the `Green` domain by synchronising changes to the provided `Green` clock.  Everything now changes only on the appropriate edge of the `Green` clock, and we have a reset, clock and inputs that are all synchronized to a single clock.  We can then drop the timing domain information from our consideration, and work in the simplified `Synchronous` mode.  

Although we will cover it more later, a `Synchronous` design is simply a `Circuit` with a simpler interface.  Recall that the `Circuit` trait involved a `CircuitIO` trait that looked like this:

```rust
pub trait CircuitIO: 'static + Sized + Clone + CircuitDQ {
    /// The input type of the circuit
    type I: Timed;
    /// The output type of the circuit
    type O: Timed;
    /// snip...
}
```

And the requirement that `I: Timed` and `O: Timed` aligns with our requirement that all signals in and out of the `Circuit` belong to some time domain.  

By contrast, the `Synchronous` trait involves a `SynchronousIO` trait that looks like this:

```rust
pub trait SynchronousIO: 'static + Sized + Clone + SynchronousDQ {
    /// The input type of the synchronous circuit
    type I: Digital;
    /// The output type of the synchronous circuit
    type O: Digital;
    /// snip...
}
```

A `Synchronous` circuit deals with simpler `Digital` types that carry no timing information, as the assumption is that all inputs and outputs are synchronized to the provided clock.  In terms of the canonical diagram for a `Synchronous` circuit, _none_ of the types are marked as `Timed`:

```badascii
                 SynchronousIO::Kernel +-+                                       
        +-------------------------------+|+-----------------------------+        
        |   +--+ SynchronousIO::I        v  SynchronousIO::O +--+       |        
  input |   v               +-----------------------+           v       | output 
 +----->+------------------>|input            output+-------------------+------->
        | +---------------->|c&r      Kernel        |                   |        
        | |            +--->|q                     d+-----+             |        
        | |            |    +-----------------------+     |             |        
        | |            |                                  |             |        
        | |            |    +-----------------------+     |             |        
        | |q.child_1+> +----+o        child_1      i|<----+ <+d.child_1 |        
        | +-----------+|+-->|c&r                    |     |             |        
        | |            |    +-----------------------+     |             |        
        | |     +----->|                                  |             |        
  clock | |     +      |    +-----------------------+     |             |        
& reset | |q.child_2+> +----+o        child_2      i|<----+ <+d.child_2 |        
 +------+-+---------------->|c&r                    |    ^              |        
  (c&r) |       +           +-----------------------+    |              |        
        |       ++ SynchronousDQ::Q    SynchronousDQ::D ++              |        
        +---------------------------------------------------------------+        
```

This means, the kernel to `Synchronous` circuit does not have `Timed` arguments, but instead, `Digital` ones, and there is no need to worry about type erasure.

```admonish note
Synchronous circuits are easier to think and reason about.  But the real world is not synchronous
and even synchronous designs rarely have a single clock for everything.  The goal of RHDL is to make
it easy to work inside of a synchronous domain, but to enforce proper handling of multiple domains
through the type system.
```